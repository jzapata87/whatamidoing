{"ast":null,"code":"import _slicedToArray from \"/Users/javierzapata/Developer/whatamidoing/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * Phoenix Channels JavaScript client\n *\n * ## Socket Connection\n *\n * A single connection is established to the server and\n * channels are multiplexed over the connection.\n * Connect to the server using the `Socket` class:\n *\n * ```javascript\n * let socket = new Socket(\"/socket\", {params: {userToken: \"123\"}})\n * socket.connect()\n * ```\n *\n * The `Socket` constructor takes the mount point of the socket,\n * the authentication params, as well as options that can be found in\n * the Socket docs, such as configuring the `LongPoll` transport, and\n * heartbeat.\n *\n * ## Channels\n *\n * Channels are isolated, concurrent processes on the server that\n * subscribe to topics and broker events between the client and server.\n * To join a channel, you must provide the topic, and channel params for\n * authorization. Here's an example chat room example where `\"new_msg\"`\n * events are listened for, messages are pushed to the server, and\n * the channel is joined with ok/error/timeout matches:\n *\n * ```javascript\n * let channel = socket.channel(\"room:123\", {token: roomToken})\n * channel.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\n * $input.onEnter( e => {\n *   channel.push(\"new_msg\", {body: e.target.val}, 10000)\n *     .receive(\"ok\", (msg) => console.log(\"created message\", msg) )\n *     .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\n *     .receive(\"timeout\", () => console.log(\"Networking issue...\") )\n * })\n *\n * channel.join()\n *   .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\n *   .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\n *   .receive(\"timeout\", () => console.log(\"Networking issue. Still waiting...\"))\n *```\n *\n * ## Joining\n *\n * Creating a channel with `socket.channel(topic, params)`, binds the params to\n * `channel.params`, which are sent up on `channel.join()`.\n * Subsequent rejoins will send up the modified params for\n * updating authorization params, or passing up last_message_id information.\n * Successful joins receive an \"ok\" status, while unsuccessful joins\n * receive \"error\".\n *\n * ## Duplicate Join Subscriptions\n *\n * While the client may join any number of topics on any number of channels,\n * the client may only hold a single subscription for each unique topic at any\n * given time. When attempting to create a duplicate subscription,\n * the server will close the existing channel, log a warning, and\n * spawn a new channel for the topic. The client will have their\n * `channel.onClose` callbacks fired for the existing channel, and the new\n * channel join will have its receive hooks processed as normal.\n *\n * ## Pushing Messages\n *\n * From the previous example, we can see that pushing messages to the server\n * can be done with `channel.push(eventName, payload)` and we can optionally\n * receive responses from the push. Additionally, we can use\n * `receive(\"timeout\", callback)` to abort waiting for our other `receive` hooks\n *  and take action after some period of waiting. The default timeout is 10000ms.\n *\n *\n * ## Socket Hooks\n *\n * Lifecycle events of the multiplexed connection can be hooked into via\n * `socket.onError()` and `socket.onClose()` events, ie:\n *\n * ```javascript\n * socket.onError( () => console.log(\"there was an error with the connection!\") )\n * socket.onClose( () => console.log(\"the connection dropped\") )\n * ```\n *\n *\n * ## Channel Hooks\n *\n * For each joined channel, you can bind to `onError` and `onClose` events\n * to monitor the channel lifecycle, ie:\n *\n * ```javascript\n * channel.onError( () => console.log(\"there was an error!\") )\n * channel.onClose( () => console.log(\"the channel has gone away gracefully\") )\n * ```\n *\n * ### onError hooks\n *\n * `onError` hooks are invoked if the socket connection drops, or the channel\n * crashes on the server. In either case, a channel rejoin is attempted\n * automatically in an exponential backoff manner.\n *\n * ### onClose hooks\n *\n * `onClose` hooks are invoked only in two cases. 1) the channel explicitly\n * closed on the server, or 2). The client explicitly closed, by calling\n * `channel.leave()`\n *\n *\n * ## Presence\n *\n * The `Presence` object provides features for syncing presence information\n * from the server with the client and handling presences joining and leaving.\n *\n * ### Syncing state from the server\n *\n * To sync presence state from the server, first instantiate an object and\n * pass your channel in to track lifecycle events:\n *\n * ```javascript\n * let channel = socket.channel(\"some:topic\")\n * let presence = new Presence(channel)\n * ```\n *\n * Next, use the `presence.onSync` callback to react to state changes\n * from the server. For example, to render the list of users every time\n * the list changes, you could write:\n *\n * ```javascript\n * presence.onSync(() => {\n *   myRenderUsersFunction(presence.list())\n * })\n * ```\n *\n * ### Listing Presences\n *\n * `presence.list` is used to return a list of presence information\n * based on the local state of metadata. By default, all presence\n * metadata is returned, but a `listBy` function can be supplied to\n * allow the client to select which metadata to use for a given presence.\n * For example, you may have a user online from different devices with\n * a metadata status of \"online\", but they have set themselves to \"away\"\n * on another device. In this case, the app may choose to use the \"away\"\n * status for what appears on the UI. The example below defines a `listBy`\n * function which prioritizes the first metadata which was registered for\n * each user. This could be the first tab they opened, or the first device\n * they came online from:\n *\n * ```javascript\n * let listBy = (id, {metas: [first, ...rest]}) => {\n *   first.count = rest.length + 1 // count of this user's presences\n *   first.id = id\n *   return first\n * }\n * let onlineUsers = presence.list(listBy)\n * ```\n *\n * ### Handling individual presence join and leave events\n *\n * The `presence.onJoin` and `presence.onLeave` callbacks can be used to\n * react to individual presences joining and leaving the app. For example:\n *\n * ```javascript\n * let presence = new Presence(channel)\n *\n * // detect if user has joined for the 1st time or from another tab/device\n * presence.onJoin((id, current, newPres) => {\n *   if(!current){\n *     console.log(\"user has entered for the first time\", newPres)\n *   } else {\n *     console.log(\"user additional presence\", newPres)\n *   }\n * })\n *\n * // detect if user has left from all tabs/devices, or is still present\n * presence.onLeave((id, current, leftPres) => {\n *   if(current.metas.length === 0){\n *     console.log(\"user has left from all devices\", leftPres)\n *   } else {\n *     console.log(\"user left from a device\", leftPres)\n *   }\n * })\n * // receive presence data from server\n * presence.onSync(() => {\n *   displayUsers(presence.list())\n * })\n * ```\n * @module phoenix\n */\nconst globalSelf = typeof self !== \"undefined\" ? self : null;\nconst globalWindow = typeof window !== \"undefined\" ? window : null;\nconst global = globalSelf || globalWindow || this;\nconst VSN = \"2.0.0\";\nconst SOCKET_STATES = {\n  connecting: 0,\n  open: 1,\n  closing: 2,\n  closed: 3\n};\nconst DEFAULT_TIMEOUT = 10000;\nconst WS_CLOSE_NORMAL = 1000;\nconst CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\"\n};\nconst CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nconst CHANNEL_LIFECYCLE_EVENTS = [CHANNEL_EVENTS.close, CHANNEL_EVENTS.error, CHANNEL_EVENTS.join, CHANNEL_EVENTS.reply, CHANNEL_EVENTS.leave];\nconst TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\" // wraps value in closure or returns closure\n\n};\n\nlet closure = value => {\n  if (typeof value === \"function\") {\n    return value;\n  } else {\n    let closure = function () {\n      return value;\n    };\n\n    return closure;\n  }\n};\n/**\n * Initializes the Push\n * @param {Channel} channel - The Channel\n * @param {string} event - The event, for example `\"phx_join\"`\n * @param {Object} payload - The payload, for example `{user_id: 123}`\n * @param {number} timeout - The push timeout in milliseconds\n */\n\n\nclass Push {\n  constructor(channel, event, payload, timeout) {\n    this.channel = channel;\n    this.event = event;\n\n    this.payload = payload || function () {\n      return {};\n    };\n\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n  /**\n   *\n   * @param {number} timeout\n   */\n\n\n  resend(timeout) {\n    this.timeout = timeout;\n    this.reset();\n    this.send();\n  }\n  /**\n   *\n   */\n\n\n  send() {\n    if (this.hasReceived(\"timeout\")) {\n      return;\n    }\n\n    this.startTimeout();\n    this.sent = true;\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    });\n  }\n  /**\n   *\n   * @param {*} status\n   * @param {*} callback\n   */\n\n\n  receive(status, callback) {\n    if (this.hasReceived(status)) {\n      callback(this.receivedResp.response);\n    }\n\n    this.recHooks.push({\n      status,\n      callback\n    });\n    return this;\n  }\n  /**\n   * @private\n   */\n\n\n  reset() {\n    this.cancelRefEvent();\n    this.ref = null;\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n  }\n  /**\n   * @private\n   */\n\n\n  matchReceive({\n    status,\n    response,\n    ref\n  }) {\n    this.recHooks.filter(h => h.status === status).forEach(h => h.callback(response));\n  }\n  /**\n   * @private\n   */\n\n\n  cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n\n    this.channel.off(this.refEvent);\n  }\n  /**\n   * @private\n   */\n\n\n  cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = null;\n  }\n  /**\n   * @private\n   */\n\n\n  startTimeout() {\n    if (this.timeoutTimer) {\n      this.cancelTimeout();\n    }\n\n    this.ref = this.channel.socket.makeRef();\n    this.refEvent = this.channel.replyEventName(this.ref);\n    this.channel.on(this.refEvent, payload => {\n      this.cancelRefEvent();\n      this.cancelTimeout();\n      this.receivedResp = payload;\n      this.matchReceive(payload);\n    });\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {});\n    }, this.timeout);\n  }\n  /**\n   * @private\n   */\n\n\n  hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n  /**\n   * @private\n   */\n\n\n  trigger(status, response) {\n    this.channel.trigger(this.refEvent, {\n      status,\n      response\n    });\n  }\n\n}\n/**\n *\n * @param {string} topic\n * @param {(Object|function)} params\n * @param {Socket} socket\n */\n\n\nexport class Channel {\n  constructor(topic, params, socket) {\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = closure(params || {});\n    this.socket = socket;\n    this.bindings = [];\n    this.bindingRef = 0;\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.rejoinTimer = new Timer(() => {\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }, this.socket.rejoinAfterMs);\n    this.socket.onError(() => this.rejoinTimer.reset());\n    this.socket.onOpen(() => {\n      this.rejoinTimer.reset();\n\n      if (this.isErrored()) {\n        this.rejoin();\n      }\n    });\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored;\n\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", \"close \".concat(this.topic, \" \").concat(this.joinRef()));\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError(reason => {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", \"error \".concat(this.topic), reason);\n\n      if (this.isJoining()) {\n        this.joinPush.reset();\n      }\n\n      this.state = CHANNEL_STATES.errored;\n\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.joinPush.receive(\"timeout\", () => {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", \"timeout \".concat(this.topic, \" (\").concat(this.joinRef(), \")\"), this.joinPush.timeout);\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n      leavePush.send();\n      this.state = CHANNEL_STATES.errored;\n      this.joinPush.reset();\n\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n  }\n  /**\n   * Join the channel\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n\n\n  join(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n    } else {\n      this.timeout = timeout;\n      this.joinedOnce = true;\n      this.rejoin();\n      return this.joinPush;\n    }\n  }\n  /**\n   * Hook into channel close\n   * @param {Function} callback\n   */\n\n\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, callback);\n  }\n  /**\n   * Hook into channel errors\n   * @param {Function} callback\n   */\n\n\n  onError(callback) {\n    return this.on(CHANNEL_EVENTS.error, reason => callback(reason));\n  }\n  /**\n   * Subscribes on channel events\n   *\n   * Subscription returns a ref counter, which can be used later to\n   * unsubscribe the exact event listener\n   *\n   * @example\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * const ref2 = channel.on(\"event\", do_other_stuff)\n   * channel.off(\"event\", ref1)\n   * // Since unsubscription, do_stuff won't fire,\n   * // while do_other_stuff will keep firing on the \"event\"\n   *\n   * @param {string} event\n   * @param {Function} callback\n   * @returns {integer} ref\n   */\n\n\n  on(event, callback) {\n    let ref = this.bindingRef++;\n    this.bindings.push({\n      event,\n      ref,\n      callback\n    });\n    return ref;\n  }\n  /**\n   * @param {string} event\n   * @param {integer} ref\n   */\n\n\n  off(event, ref) {\n    this.bindings = this.bindings.filter(bind => {\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n  /**\n   * @param {string} event\n   * @param {Object} payload\n   * @param {number} [timeout]\n   * @returns {Push}\n   */\n\n\n  push(event, payload, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw new Error(\"tried to push '\".concat(event, \"' to '\").concat(this.topic, \"' before joining. Use channel.join() before pushing events\"));\n    }\n\n    let pushEvent = new Push(this, event, function () {\n      return payload;\n    }, timeout);\n\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n\n    return pushEvent;\n  }\n  /** Leaves the channel\n   *\n   * Unsubscribes from server events, and\n   * instructs channel to terminate on server\n   *\n   * Triggers onClose() hooks\n   *\n   * To receive leave acknowledgements, use the a `receive`\n   * hook to bind to the server ack, ie:\n   *\n   * @example\n   * channel.leave().receive(\"ok\", () => alert(\"left!\") )\n   *\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n\n\n  leave(timeout = this.timeout) {\n    this.rejoinTimer.reset();\n    this.state = CHANNEL_STATES.leaving;\n\n    let onClose = () => {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", \"leave \".concat(this.topic));\n      this.trigger(CHANNEL_EVENTS.close, \"leave\");\n    };\n\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n    leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\n    leavePush.send();\n\n    if (!this.canPush()) {\n      leavePush.trigger(\"ok\", {});\n    }\n\n    return leavePush;\n  }\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling\n   * before dispatching to the channel callbacks.\n   *\n   * Must return the payload, modified or unmodified\n   * @param {string} event\n   * @param {Object} payload\n   * @param {integer} ref\n   * @returns {Object}\n   */\n\n\n  onMessage(event, payload, ref) {\n    return payload;\n  }\n  /**\n   * @private\n   */\n\n\n  isLifecycleEvent(event) {\n    return CHANNEL_LIFECYCLE_EVENTS.indexOf(event) >= 0;\n  }\n  /**\n   * @private\n   */\n\n\n  isMember(topic, event, payload, joinRef) {\n    if (this.topic !== topic) {\n      return false;\n    }\n\n    if (joinRef && joinRef !== this.joinRef() && this.isLifecycleEvent(event)) {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", \"dropping outdated message\", {\n        topic,\n        event,\n        payload,\n        joinRef\n      });\n      return false;\n    } else {\n      return true;\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  joinRef() {\n    return this.joinPush.ref;\n  }\n  /**\n   * @private\n   */\n\n\n  sendJoin(timeout) {\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  /**\n   * @private\n   */\n\n\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return;\n    }\n\n    this.sendJoin(timeout);\n  }\n  /**\n   * @private\n   */\n\n\n  trigger(event, payload, ref, joinRef) {\n    let handledPayload = this.onMessage(event, payload, ref, joinRef);\n\n    if (payload && !handledPayload) {\n      throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n    }\n\n    for (let i = 0; i < this.bindings.length; i++) {\n      const bind = this.bindings[i];\n\n      if (bind.event !== event) {\n        continue;\n      }\n\n      bind.callback(handledPayload, ref, joinRef || this.joinRef());\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  replyEventName(ref) {\n    return \"chan_reply_\".concat(ref);\n  }\n  /**\n   * @private\n   */\n\n\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  /**\n   * @private\n   */\n\n\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n  /**\n   * @private\n   */\n\n\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  /**\n   * @private\n   */\n\n\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  /**\n   * @private\n   */\n\n\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n\n}\n/* The default serializer for encoding and decoding messages */\n\nexport let Serializer = {\n  encode(msg, callback) {\n    let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n    return callback(JSON.stringify(payload));\n  },\n\n  decode(rawPayload, callback) {\n    let _JSON$parse = JSON.parse(rawPayload),\n        _JSON$parse2 = _slicedToArray(_JSON$parse, 5),\n        join_ref = _JSON$parse2[0],\n        ref = _JSON$parse2[1],\n        topic = _JSON$parse2[2],\n        event = _JSON$parse2[3],\n        payload = _JSON$parse2[4];\n\n    return callback({\n      join_ref,\n      ref,\n      topic,\n      event,\n      payload\n    });\n  }\n\n};\n/** Initializes the Socket\n *\n *\n * For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n *\n * @param {string} endPoint - The string WebSocket endpoint, ie, `\"ws://example.com/socket\"`,\n *                                               `\"wss://example.com\"`\n *                                               `\"/socket\"` (inherited host & protocol)\n * @param {Object} [opts] - Optional configuration\n * @param {string} [opts.transport] - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n *\n * Defaults to WebSocket with automatic LongPoll fallback.\n * @param {Function} [opts.encode] - The function to encode outgoing messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.stringify(payload))\n * ```\n *\n * @param {Function} [opts.decode] - The function to decode incoming messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.parse(payload))\n * ```\n *\n * @param {number} [opts.timeout] - The default timeout in milliseconds to trigger push timeouts.\n *\n * Defaults `DEFAULT_TIMEOUT`\n * @param {number} [opts.heartbeatIntervalMs] - The millisec interval to send a heartbeat message\n * @param {number} [opts.reconnectAfterMs] - The optional function that returns the millsec\n * socket reconnect interval.\n *\n * Defaults to stepped backoff of:\n *\n * ```javascript\n * function(tries){\n *   return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000\n * }\n * ````\n *\n * @param {number} [opts.rejoinAfterMs] - The optional function that returns the millsec\n * rejoin interval for individual channels.\n *\n * ```javascript\n * function(tries){\n *   return [1000, 2000, 5000][tries - 1] || 10000\n * }\n * ````\n *\n * @param {Function} [opts.logger] - The optional function for specialized logging, ie:\n *\n * ```javascript\n * function(kind, msg, data) {\n *   console.log(`${kind}: ${msg}`, data)\n * }\n * ```\n *\n * @param {number} [opts.longpollerTimeout] - The maximum timeout of a long poll AJAX request.\n *\n * Defaults to 20s (double the server long poll timer).\n *\n * @param {{Object|function)} [opts.params] - The optional params to pass when connecting\n * @param {string} [opts.binaryType] - The binary type to use for binary WebSocket frames.\n *\n * Defaults to \"arraybuffer\"\n *\n*/\n\nexport class Socket {\n  constructor(endPoint, opts = {}) {\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || global.WebSocket || LongPoll;\n    this.defaultEncoder = Serializer.encode;\n    this.defaultDecoder = Serializer.decode;\n    this.closeWasClean = false;\n    this.unloaded = false;\n    this.binaryType = opts.binaryType || \"arraybuffer\";\n\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder;\n      this.decode = opts.decode || this.defaultDecoder;\n    } else {\n      this.encode = this.defaultEncoder;\n      this.decode = this.defaultDecoder;\n    }\n\n    if (globalWindow) {\n      globalWindow.addEventListener(\"beforeunload\", e => {\n        this.unloaded = true;\n        this.abnormalClose(\"unloaded\");\n      });\n    }\n\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000;\n\n    this.rejoinAfterMs = tries => {\n      if (opts.rejoinAfterMs) {\n        return opts.rejoinAfterMs(tries);\n      } else {\n        return [1000, 2000, 5000][tries - 1] || 10000;\n      }\n    };\n\n    this.reconnectAfterMs = tries => {\n      if (this.unloaded) {\n        return 100;\n      }\n\n      if (opts.reconnectAfterMs) {\n        return opts.reconnectAfterMs(tries);\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000;\n      }\n    };\n\n    this.logger = opts.logger || null;\n    this.longpollerTimeout = opts.longpollerTimeout || 20000;\n    this.params = closure(opts.params || {});\n    this.endPoint = \"\".concat(endPoint, \"/\").concat(TRANSPORTS.websocket);\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(() => {\n      this.teardown(() => this.connect());\n    }, this.reconnectAfterMs);\n  }\n  /**\n   * Returns the socket protocol\n   *\n   * @returns {string}\n   */\n\n\n  protocol() {\n    return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n  }\n  /**\n   * The fully qualifed socket url\n   *\n   * @returns {string}\n   */\n\n\n  endPointURL() {\n    let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), {\n      vsn: VSN\n    });\n\n    if (uri.charAt(0) !== \"/\") {\n      return uri;\n    }\n\n    if (uri.charAt(1) === \"/\") {\n      return \"\".concat(this.protocol(), \":\").concat(uri);\n    }\n\n    return \"\".concat(this.protocol(), \"://\").concat(location.host).concat(uri);\n  }\n  /**\n   * @param {Function} callback\n   * @param {integer} code\n   * @param {string} reason\n   */\n\n\n  disconnect(callback, code, reason) {\n    this.closeWasClean = true;\n    this.reconnectTimer.reset();\n    this.teardown(callback, code, reason);\n  }\n  /**\n   *\n   * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`\n   *\n   * Passing params to connect is deprecated; pass them in the Socket constructor instead:\n   * `new Socket(\"/socket\", {params: {user_id: userToken}})`.\n   */\n\n\n  connect(params) {\n    if (params) {\n      console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n      this.params = closure(params);\n    }\n\n    if (this.conn) {\n      return;\n    }\n\n    this.conn = new this.transport(this.endPointURL());\n    this.conn.binaryType = this.binaryType;\n    this.conn.timeout = this.longpollerTimeout;\n\n    this.conn.onopen = () => this.onConnOpen();\n\n    this.conn.onerror = error => this.onConnError(error);\n\n    this.conn.onmessage = event => this.onConnMessage(event);\n\n    this.conn.onclose = event => this.onConnClose(event);\n  }\n  /**\n   * Logs the message. Override `this.logger` for specialized logging. noops by default\n   * @param {string} kind\n   * @param {string} msg\n   * @param {Object} data\n   */\n\n\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  /**\n   * Returns true if a logger has been set on this socket.\n   */\n\n\n  hasLogger() {\n    return this.logger !== null;\n  }\n  /**\n   * Registers callbacks for connection open events\n   *\n   * @example socket.onOpen(function(){ console.info(\"the socket was opened\") })\n   *\n   * @param {Function} callback\n   */\n\n\n  onOpen(callback) {\n    this.stateChangeCallbacks.open.push(callback);\n  }\n  /**\n   * Registers callbacks for connection close events\n   * @param {Function} callback\n   */\n\n\n  onClose(callback) {\n    this.stateChangeCallbacks.close.push(callback);\n  }\n  /**\n   * Registers callbacks for connection error events\n   *\n   * @example socket.onError(function(error){ alert(\"An error occurred\") })\n   *\n   * @param {Function} callback\n   */\n\n\n  onError(callback) {\n    this.stateChangeCallbacks.error.push(callback);\n  }\n  /**\n   * Registers callbacks for connection message events\n   * @param {Function} callback\n   */\n\n\n  onMessage(callback) {\n    this.stateChangeCallbacks.message.push(callback);\n  }\n  /**\n   * @private\n   */\n\n\n  onConnOpen() {\n    if (this.hasLogger()) this.log(\"transport\", \"connected to \".concat(this.endPointURL()));\n    this.unloaded = false;\n    this.closeWasClean = false;\n    this.flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.resetHeartbeat();\n    this.stateChangeCallbacks.open.forEach(callback => callback());\n  }\n  /**\n   * @private\n   */\n\n\n  resetHeartbeat() {\n    if (this.conn.skipHeartbeat) {\n      return;\n    }\n\n    this.pendingHeartbeatRef = null;\n    clearInterval(this.heartbeatTimer);\n    this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n  }\n\n  teardown(callback, code, reason) {\n    if (this.conn) {\n      this.conn.onclose = function () {}; // noop\n\n\n      if (code) {\n        this.conn.close(code, reason || \"\");\n      } else {\n        this.conn.close();\n      }\n\n      this.conn = null;\n    }\n\n    callback && callback();\n  }\n\n  onConnClose(event) {\n    if (this.hasLogger()) this.log(\"transport\", \"close\", event);\n    this.triggerChanError();\n    clearInterval(this.heartbeatTimer);\n\n    if (!this.closeWasClean) {\n      this.reconnectTimer.scheduleTimeout();\n    }\n\n    this.stateChangeCallbacks.close.forEach(callback => callback(event));\n  }\n  /**\n   * @private\n   */\n\n\n  onConnError(error) {\n    if (this.hasLogger()) this.log(\"transport\", error);\n    this.triggerChanError();\n    this.stateChangeCallbacks.error.forEach(callback => callback(error));\n  }\n  /**\n   * @private\n   */\n\n\n  triggerChanError() {\n    this.channels.forEach(channel => {\n      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n        channel.trigger(CHANNEL_EVENTS.error);\n      }\n    });\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return \"connecting\";\n\n      case SOCKET_STATES.open:\n        return \"open\";\n\n      case SOCKET_STATES.closing:\n        return \"closing\";\n\n      default:\n        return \"closed\";\n    }\n  }\n  /**\n   * @returns {boolean}\n   */\n\n\n  isConnected() {\n    return this.connectionState() === \"open\";\n  }\n  /**\n   * @param {Channel}\n   */\n\n\n  remove(channel) {\n    this.channels = this.channels.filter(c => c.joinRef() !== channel.joinRef());\n  }\n  /**\n   * Initiates a new channel for the given topic\n   *\n   * @param {string} topic\n   * @param {Object} chanParams - Parameters for the channel\n   * @returns {Channel}\n   */\n\n\n  channel(topic, chanParams = {}) {\n    let chan = new Channel(topic, chanParams, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  /**\n   * @param {Object} data\n   */\n\n\n  push(data) {\n    if (this.hasLogger()) {\n      let topic = data.topic,\n          event = data.event,\n          payload = data.payload,\n          ref = data.ref,\n          join_ref = data.join_ref;\n      this.log(\"push\", \"\".concat(topic, \" \").concat(event, \" (\").concat(join_ref, \", \").concat(ref, \")\"), payload);\n    }\n\n    if (this.isConnected()) {\n      this.encode(data, result => this.conn.send(result));\n    } else {\n      this.sendBuffer.push(() => this.encode(data, result => this.conn.send(result)));\n    }\n  }\n  /**\n   * Return the next message ref, accounting for overflows\n   * @returns {string}\n   */\n\n\n  makeRef() {\n    let newRef = this.ref + 1;\n\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n\n    return this.ref.toString();\n  }\n\n  sendHeartbeat() {\n    if (!this.isConnected()) {\n      return;\n    }\n\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      if (this.hasLogger()) this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n      this.abnormalClose(\"heartbeat timeout\");\n      return;\n    }\n\n    this.pendingHeartbeatRef = this.makeRef();\n    this.push({\n      topic: \"phoenix\",\n      event: \"heartbeat\",\n      payload: {},\n      ref: this.pendingHeartbeatRef\n    });\n  }\n\n  abnormalClose(reason) {\n    this.closeWasClean = false;\n    this.conn.close(WS_CLOSE_NORMAL, reason);\n  }\n\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n\n  onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      let topic = msg.topic,\n          event = msg.event,\n          payload = msg.payload,\n          ref = msg.ref,\n          join_ref = msg.join_ref;\n\n      if (ref && ref === this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n      }\n\n      if (this.hasLogger()) this.log(\"receive\", \"\".concat(payload.status || \"\", \" \").concat(topic, \" \").concat(event, \" \").concat(ref && \"(\" + ref + \")\" || \"\"), payload);\n\n      for (let i = 0; i < this.channels.length; i++) {\n        const channel = this.channels[i];\n\n        if (!channel.isMember(topic, event, payload, join_ref)) {\n          continue;\n        }\n\n        channel.trigger(event, payload, ref, join_ref);\n      }\n\n      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n        this.stateChangeCallbacks.message[i](msg);\n      }\n    });\n  }\n\n}\nexport class LongPoll {\n  constructor(endPoint) {\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n\n    this.onopen = function () {}; // noop\n\n\n    this.onerror = function () {}; // noop\n\n\n    this.onmessage = function () {}; // noop\n\n\n    this.onclose = function () {}; // noop\n\n\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n    this.poll();\n  }\n\n  normalizeEndpoint(endPoint) {\n    return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)\\/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n  }\n\n  endpointURL() {\n    return Ajax.appendParams(this.pollEndpoint, {\n      token: this.token\n    });\n  }\n\n  closeAndRetry() {\n    this.close();\n    this.readyState = SOCKET_STATES.connecting;\n  }\n\n  ontimeout() {\n    this.onerror(\"timeout\");\n    this.closeAndRetry();\n  }\n\n  poll() {\n    if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n      return;\n    }\n\n    Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), resp => {\n      if (resp) {\n        var status = resp.status,\n            token = resp.token,\n            messages = resp.messages;\n        this.token = token;\n      } else {\n        var status = 0;\n      }\n\n      switch (status) {\n        case 200:\n          messages.forEach(msg => this.onmessage({\n            data: msg\n          }));\n          this.poll();\n          break;\n\n        case 204:\n          this.poll();\n          break;\n\n        case 410:\n          this.readyState = SOCKET_STATES.open;\n          this.onopen();\n          this.poll();\n          break;\n\n        case 0:\n        case 500:\n          this.onerror();\n          this.closeAndRetry();\n          break;\n\n        default:\n          throw new Error(\"unhandled poll status \".concat(status));\n      }\n    });\n  }\n\n  send(body) {\n    Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), resp => {\n      if (!resp || resp.status !== 200) {\n        this.onerror(resp && resp.status);\n        this.closeAndRetry();\n      }\n    });\n  }\n\n  close(code, reason) {\n    this.readyState = SOCKET_STATES.closed;\n    this.onclose();\n  }\n\n}\nexport class Ajax {\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n    if (global.XDomainRequest) {\n      let req = new XDomainRequest(); // IE8, IE9\n\n      this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n    } else {\n      let req = global.XMLHttpRequest ? new global.XMLHttpRequest() : // IE7+, Firefox, Chrome, Opera, Safari\n      new ActiveXObject(\"Microsoft.XMLHTTP\"); // IE6, IE5\n\n      this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n    }\n  }\n\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n    req.timeout = timeout;\n    req.open(method, endPoint);\n\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText);\n      callback && callback(response);\n    };\n\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    } // Work around bug in IE9 that requires an attached onprogress handler\n\n\n    req.onprogress = () => {};\n\n    req.send(body);\n  }\n\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n    req.open(method, endPoint, true);\n    req.timeout = timeout;\n    req.setRequestHeader(\"Content-Type\", accept);\n\n    req.onerror = () => {\n      callback && callback(null);\n    };\n\n    req.onreadystatechange = () => {\n      if (req.readyState === this.states.complete && callback) {\n        let response = this.parseJSON(req.responseText);\n        callback(response);\n      }\n    };\n\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n\n    req.send(body);\n  }\n\n  static parseJSON(resp) {\n    if (!resp || resp === \"\") {\n      return null;\n    }\n\n    try {\n      return JSON.parse(resp);\n    } catch (e) {\n      console && console.log(\"failed to parse JSON response\", resp);\n      return null;\n    }\n  }\n\n  static serialize(obj, parentKey) {\n    let queryStr = [];\n\n    for (var key in obj) {\n      if (!obj.hasOwnProperty(key)) {\n        continue;\n      }\n\n      let paramKey = parentKey ? \"\".concat(parentKey, \"[\").concat(key, \"]\") : key;\n      let paramVal = obj[key];\n\n      if (typeof paramVal === \"object\") {\n        queryStr.push(this.serialize(paramVal, paramKey));\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n      }\n    }\n\n    return queryStr.join(\"&\");\n  }\n\n  static appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\";\n    return \"\".concat(url).concat(prefix).concat(this.serialize(params));\n  }\n\n}\nAjax.states = {\n  complete: 4\n  /**\n   * Initializes the Presence\n   * @param {Channel} channel - The Channel\n   * @param {Object} opts - The options,\n   *        for example `{events: {state: \"state\", diff: \"diff\"}}`\n   */\n\n};\nexport class Presence {\n  constructor(channel, opts = {}) {\n    let events = opts.events || {\n      state: \"presence_state\",\n      diff: \"presence_diff\"\n    };\n    this.state = {};\n    this.pendingDiffs = [];\n    this.channel = channel;\n    this.joinRef = null;\n    this.caller = {\n      onJoin: function () {},\n      onLeave: function () {},\n      onSync: function () {}\n    };\n    this.channel.on(events.state, newState => {\n      let _this$caller = this.caller,\n          onJoin = _this$caller.onJoin,\n          onLeave = _this$caller.onLeave,\n          onSync = _this$caller.onSync;\n      this.joinRef = this.channel.joinRef();\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n      this.pendingDiffs.forEach(diff => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n    this.channel.on(events.diff, diff => {\n      let _this$caller2 = this.caller,\n          onJoin = _this$caller2.onJoin,\n          onLeave = _this$caller2.onLeave,\n          onSync = _this$caller2.onSync;\n\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n  }\n\n  onJoin(callback) {\n    this.caller.onJoin = callback;\n  }\n\n  onLeave(callback) {\n    this.caller.onLeave = callback;\n  }\n\n  onSync(callback) {\n    this.caller.onSync = callback;\n  }\n\n  list(by) {\n    return Presence.list(this.state, by);\n  }\n\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel.joinRef();\n  } // lower-level public static API\n\n  /**\n   * Used to sync the list of presences on the server\n   * with the client's state. An optional `onJoin` and `onLeave` callback can\n   * be provided to react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   *\n   * @returns {Presence}\n   */\n\n\n  static syncState(currentState, newState, onJoin, onLeave) {\n    let state = this.clone(currentState);\n    let joins = {};\n    let leaves = {};\n    this.map(state, (key, presence) => {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key];\n\n      if (currentPresence) {\n        let newRefs = newPresence.metas.map(m => m.phx_ref);\n        let curRefs = currentPresence.metas.map(m => m.phx_ref);\n        let joinedMetas = newPresence.metas.filter(m => curRefs.indexOf(m.phx_ref) < 0);\n        let leftMetas = currentPresence.metas.filter(m => newRefs.indexOf(m.phx_ref) < 0);\n\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence;\n          joins[key].metas = joinedMetas;\n        }\n\n        if (leftMetas.length > 0) {\n          leaves[key] = this.clone(currentPresence);\n          leaves[key].metas = leftMetas;\n        }\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, {\n      joins: joins,\n      leaves: leaves\n    }, onJoin, onLeave);\n  }\n  /**\n   *\n   * Used to sync a diff of presence join and leave\n   * events from the server, as they happen. Like `syncState`, `syncDiff`\n   * accepts optional `onJoin` and `onLeave` callbacks to react to a user\n   * joining or leaving from a device.\n   *\n   * @returns {Presence}\n   */\n\n\n  static syncDiff(currentState, {\n    joins,\n    leaves\n  }, onJoin, onLeave) {\n    let state = this.clone(currentState);\n\n    if (!onJoin) {\n      onJoin = function () {};\n    }\n\n    if (!onLeave) {\n      onLeave = function () {};\n    }\n\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key];\n      state[key] = newPresence;\n\n      if (currentPresence) {\n        let joinedRefs = state[key].metas.map(m => m.phx_ref);\n        let curMetas = currentPresence.metas.filter(m => joinedRefs.indexOf(m.phx_ref) < 0);\n        state[key].metas.unshift(...curMetas);\n      }\n\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key];\n\n      if (!currentPresence) {\n        return;\n      }\n\n      let refsToRemove = leftPresence.metas.map(m => m.phx_ref);\n      currentPresence.metas = currentPresence.metas.filter(p => {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  }\n  /**\n   * Returns the array of presences, with selected metadata.\n   *\n   * @param {Object} presences\n   * @param {Function} chooser\n   *\n   * @returns {Presence}\n   */\n\n\n  static list(presences, chooser) {\n    if (!chooser) {\n      chooser = function (key, pres) {\n        return pres;\n      };\n    }\n\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence);\n    });\n  } // private\n\n\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]));\n  }\n\n  static clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n}\n/**\n *\n * Creates a timer that accepts a `timerCalc` function to perform\n * calculated timeout retries, such as exponential backoff.\n *\n * @example\n * let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *   return [1000, 5000, 10000][tries - 1] || 10000\n * })\n * reconnectTimer.scheduleTimeout() // fires after 1000\n * reconnectTimer.scheduleTimeout() // fires after 5000\n * reconnectTimer.reset()\n * reconnectTimer.scheduleTimeout() // fires after 1000\n *\n * @param {Function} callback\n * @param {Function} timerCalc\n */\n\nclass Timer {\n  constructor(callback, timerCalc) {\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n\n  reset() {\n    this.tries = 0;\n    clearTimeout(this.timer);\n  }\n  /**\n   * Cancels any previous scheduleTimeout and schedules callback\n   */\n\n\n  scheduleTimeout() {\n    clearTimeout(this.timer);\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1;\n      this.callback();\n    }, this.timerCalc(this.tries + 1));\n  }\n\n}","map":{"version":3,"sources":["/Users/javierzapata/Developer/whatamidoing/src/phoenix.js"],"names":["globalSelf","self","globalWindow","window","global","VSN","SOCKET_STATES","connecting","open","closing","closed","DEFAULT_TIMEOUT","WS_CLOSE_NORMAL","CHANNEL_STATES","errored","joined","joining","leaving","CHANNEL_EVENTS","close","error","join","reply","leave","CHANNEL_LIFECYCLE_EVENTS","TRANSPORTS","longpoll","websocket","closure","value","Push","constructor","channel","event","payload","timeout","receivedResp","timeoutTimer","recHooks","sent","resend","reset","send","hasReceived","startTimeout","socket","push","topic","ref","join_ref","joinRef","receive","status","callback","response","cancelRefEvent","refEvent","matchReceive","filter","h","forEach","off","cancelTimeout","clearTimeout","makeRef","replyEventName","on","setTimeout","trigger","Channel","params","state","bindings","bindingRef","joinedOnce","joinPush","pushBuffer","rejoinTimer","Timer","isConnected","rejoin","rejoinAfterMs","onError","onOpen","isErrored","pushEvent","scheduleTimeout","onClose","hasLogger","log","remove","reason","isJoining","leavePush","Error","bind","canPush","isJoined","onMessage","isLifecycleEvent","indexOf","isMember","sendJoin","isLeaving","handledPayload","i","length","isClosed","Serializer","encode","msg","JSON","stringify","decode","rawPayload","parse","Socket","endPoint","opts","stateChangeCallbacks","message","channels","sendBuffer","transport","WebSocket","LongPoll","defaultEncoder","defaultDecoder","closeWasClean","unloaded","binaryType","addEventListener","e","abnormalClose","heartbeatIntervalMs","tries","reconnectAfterMs","logger","longpollerTimeout","heartbeatTimer","pendingHeartbeatRef","reconnectTimer","teardown","connect","protocol","location","match","endPointURL","uri","Ajax","appendParams","vsn","charAt","host","disconnect","code","console","conn","onopen","onConnOpen","onerror","onConnError","onmessage","onConnMessage","onclose","onConnClose","kind","data","flushSendBuffer","resetHeartbeat","skipHeartbeat","clearInterval","setInterval","sendHeartbeat","triggerChanError","connectionState","readyState","c","chanParams","chan","result","newRef","toString","rawMessage","token","pollEndpoint","normalizeEndpoint","poll","replace","RegExp","endpointURL","closeAndRetry","ontimeout","request","resp","messages","body","method","accept","XDomainRequest","req","xdomainRequest","XMLHttpRequest","ActiveXObject","xhrRequest","onload","parseJSON","responseText","onprogress","setRequestHeader","onreadystatechange","states","complete","serialize","obj","parentKey","queryStr","key","hasOwnProperty","paramKey","paramVal","encodeURIComponent","url","Object","keys","prefix","Presence","events","diff","pendingDiffs","caller","onJoin","onLeave","onSync","newState","syncState","syncDiff","inPendingSyncState","list","by","currentState","clone","joins","leaves","map","presence","newPresence","currentPresence","newRefs","metas","m","phx_ref","curRefs","joinedMetas","leftMetas","joinedRefs","curMetas","unshift","leftPresence","refsToRemove","p","presences","chooser","pres","func","getOwnPropertyNames","timerCalc","timer"],"mappings":"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","sourcesContent":["/**\n * Phoenix Channels JavaScript client\n *\n * ## Socket Connection\n *\n * A single connection is established to the server and\n * channels are multiplexed over the connection.\n * Connect to the server using the `Socket` class:\n *\n * ```javascript\n * let socket = new Socket(\"/socket\", {params: {userToken: \"123\"}})\n * socket.connect()\n * ```\n *\n * The `Socket` constructor takes the mount point of the socket,\n * the authentication params, as well as options that can be found in\n * the Socket docs, such as configuring the `LongPoll` transport, and\n * heartbeat.\n *\n * ## Channels\n *\n * Channels are isolated, concurrent processes on the server that\n * subscribe to topics and broker events between the client and server.\n * To join a channel, you must provide the topic, and channel params for\n * authorization. Here's an example chat room example where `\"new_msg\"`\n * events are listened for, messages are pushed to the server, and\n * the channel is joined with ok/error/timeout matches:\n *\n * ```javascript\n * let channel = socket.channel(\"room:123\", {token: roomToken})\n * channel.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\n * $input.onEnter( e => {\n *   channel.push(\"new_msg\", {body: e.target.val}, 10000)\n *     .receive(\"ok\", (msg) => console.log(\"created message\", msg) )\n *     .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\n *     .receive(\"timeout\", () => console.log(\"Networking issue...\") )\n * })\n *\n * channel.join()\n *   .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\n *   .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\n *   .receive(\"timeout\", () => console.log(\"Networking issue. Still waiting...\"))\n *```\n *\n * ## Joining\n *\n * Creating a channel with `socket.channel(topic, params)`, binds the params to\n * `channel.params`, which are sent up on `channel.join()`.\n * Subsequent rejoins will send up the modified params for\n * updating authorization params, or passing up last_message_id information.\n * Successful joins receive an \"ok\" status, while unsuccessful joins\n * receive \"error\".\n *\n * ## Duplicate Join Subscriptions\n *\n * While the client may join any number of topics on any number of channels,\n * the client may only hold a single subscription for each unique topic at any\n * given time. When attempting to create a duplicate subscription,\n * the server will close the existing channel, log a warning, and\n * spawn a new channel for the topic. The client will have their\n * `channel.onClose` callbacks fired for the existing channel, and the new\n * channel join will have its receive hooks processed as normal.\n *\n * ## Pushing Messages\n *\n * From the previous example, we can see that pushing messages to the server\n * can be done with `channel.push(eventName, payload)` and we can optionally\n * receive responses from the push. Additionally, we can use\n * `receive(\"timeout\", callback)` to abort waiting for our other `receive` hooks\n *  and take action after some period of waiting. The default timeout is 10000ms.\n *\n *\n * ## Socket Hooks\n *\n * Lifecycle events of the multiplexed connection can be hooked into via\n * `socket.onError()` and `socket.onClose()` events, ie:\n *\n * ```javascript\n * socket.onError( () => console.log(\"there was an error with the connection!\") )\n * socket.onClose( () => console.log(\"the connection dropped\") )\n * ```\n *\n *\n * ## Channel Hooks\n *\n * For each joined channel, you can bind to `onError` and `onClose` events\n * to monitor the channel lifecycle, ie:\n *\n * ```javascript\n * channel.onError( () => console.log(\"there was an error!\") )\n * channel.onClose( () => console.log(\"the channel has gone away gracefully\") )\n * ```\n *\n * ### onError hooks\n *\n * `onError` hooks are invoked if the socket connection drops, or the channel\n * crashes on the server. In either case, a channel rejoin is attempted\n * automatically in an exponential backoff manner.\n *\n * ### onClose hooks\n *\n * `onClose` hooks are invoked only in two cases. 1) the channel explicitly\n * closed on the server, or 2). The client explicitly closed, by calling\n * `channel.leave()`\n *\n *\n * ## Presence\n *\n * The `Presence` object provides features for syncing presence information\n * from the server with the client and handling presences joining and leaving.\n *\n * ### Syncing state from the server\n *\n * To sync presence state from the server, first instantiate an object and\n * pass your channel in to track lifecycle events:\n *\n * ```javascript\n * let channel = socket.channel(\"some:topic\")\n * let presence = new Presence(channel)\n * ```\n *\n * Next, use the `presence.onSync` callback to react to state changes\n * from the server. For example, to render the list of users every time\n * the list changes, you could write:\n *\n * ```javascript\n * presence.onSync(() => {\n *   myRenderUsersFunction(presence.list())\n * })\n * ```\n *\n * ### Listing Presences\n *\n * `presence.list` is used to return a list of presence information\n * based on the local state of metadata. By default, all presence\n * metadata is returned, but a `listBy` function can be supplied to\n * allow the client to select which metadata to use for a given presence.\n * For example, you may have a user online from different devices with\n * a metadata status of \"online\", but they have set themselves to \"away\"\n * on another device. In this case, the app may choose to use the \"away\"\n * status for what appears on the UI. The example below defines a `listBy`\n * function which prioritizes the first metadata which was registered for\n * each user. This could be the first tab they opened, or the first device\n * they came online from:\n *\n * ```javascript\n * let listBy = (id, {metas: [first, ...rest]}) => {\n *   first.count = rest.length + 1 // count of this user's presences\n *   first.id = id\n *   return first\n * }\n * let onlineUsers = presence.list(listBy)\n * ```\n *\n * ### Handling individual presence join and leave events\n *\n * The `presence.onJoin` and `presence.onLeave` callbacks can be used to\n * react to individual presences joining and leaving the app. For example:\n *\n * ```javascript\n * let presence = new Presence(channel)\n *\n * // detect if user has joined for the 1st time or from another tab/device\n * presence.onJoin((id, current, newPres) => {\n *   if(!current){\n *     console.log(\"user has entered for the first time\", newPres)\n *   } else {\n *     console.log(\"user additional presence\", newPres)\n *   }\n * })\n *\n * // detect if user has left from all tabs/devices, or is still present\n * presence.onLeave((id, current, leftPres) => {\n *   if(current.metas.length === 0){\n *     console.log(\"user has left from all devices\", leftPres)\n *   } else {\n *     console.log(\"user left from a device\", leftPres)\n *   }\n * })\n * // receive presence data from server\n * presence.onSync(() => {\n *   displayUsers(presence.list())\n * })\n * ```\n * @module phoenix\n */\n\nconst globalSelf = typeof self !== \"undefined\" ? self : null\nconst globalWindow = typeof window !== \"undefined\" ? window : null\nconst global = globalSelf || globalWindow || this\nconst VSN = \"2.0.0\"\nconst SOCKET_STATES = {connecting: 0, open: 1, closing: 2, closed: 3}\nconst DEFAULT_TIMEOUT = 10000\nconst WS_CLOSE_NORMAL = 1000\nconst CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\",\n}\nconst CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n}\nconst CHANNEL_LIFECYCLE_EVENTS = [\n  CHANNEL_EVENTS.close,\n  CHANNEL_EVENTS.error,\n  CHANNEL_EVENTS.join,\n  CHANNEL_EVENTS.reply,\n  CHANNEL_EVENTS.leave\n]\nconst TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n}\n\n// wraps value in closure or returns closure\nlet closure = (value) => {\n  if(typeof value === \"function\"){\n    return value\n  } else {\n    let closure = function(){ return value }\n    return closure\n  }\n}\n\n/**\n * Initializes the Push\n * @param {Channel} channel - The Channel\n * @param {string} event - The event, for example `\"phx_join\"`\n * @param {Object} payload - The payload, for example `{user_id: 123}`\n * @param {number} timeout - The push timeout in milliseconds\n */\nclass Push {\n  constructor(channel, event, payload, timeout){\n    this.channel      = channel\n    this.event        = event\n    this.payload      = payload || function(){ return {} }\n    this.receivedResp = null\n    this.timeout      = timeout\n    this.timeoutTimer = null\n    this.recHooks     = []\n    this.sent         = false\n  }\n\n  /**\n   *\n   * @param {number} timeout\n   */\n  resend(timeout){\n    this.timeout = timeout\n    this.reset()\n    this.send()\n  }\n\n  /**\n   *\n   */\n  send(){ if(this.hasReceived(\"timeout\")){ return }\n    this.startTimeout()\n    this.sent = true\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    })\n  }\n\n  /**\n   *\n   * @param {*} status\n   * @param {*} callback\n   */\n  receive(status, callback){\n    if(this.hasReceived(status)){\n      callback(this.receivedResp.response)\n    }\n\n    this.recHooks.push({status, callback})\n    return this\n  }\n\n  /**\n   * @private\n   */\n  reset(){\n    this.cancelRefEvent()\n    this.ref          = null\n    this.refEvent     = null\n    this.receivedResp = null\n    this.sent         = false\n  }\n\n  /**\n   * @private\n   */\n  matchReceive({status, response, ref}){\n    this.recHooks.filter( h => h.status === status )\n                 .forEach( h => h.callback(response) )\n  }\n\n  /**\n   * @private\n   */\n  cancelRefEvent(){ if(!this.refEvent){ return }\n    this.channel.off(this.refEvent)\n  }\n\n  /**\n   * @private\n   */\n  cancelTimeout(){\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = null\n  }\n\n  /**\n   * @private\n   */\n  startTimeout(){ if(this.timeoutTimer){ this.cancelTimeout() }\n    this.ref      = this.channel.socket.makeRef()\n    this.refEvent = this.channel.replyEventName(this.ref)\n\n    this.channel.on(this.refEvent, payload => {\n      this.cancelRefEvent()\n      this.cancelTimeout()\n      this.receivedResp = payload\n      this.matchReceive(payload)\n    })\n\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {})\n    }, this.timeout)\n  }\n\n  /**\n   * @private\n   */\n  hasReceived(status){\n    return this.receivedResp && this.receivedResp.status === status\n  }\n\n  /**\n   * @private\n   */\n  trigger(status, response){\n    this.channel.trigger(this.refEvent, {status, response})\n  }\n}\n\n/**\n *\n * @param {string} topic\n * @param {(Object|function)} params\n * @param {Socket} socket\n */\nexport class Channel {\n  constructor(topic, params, socket) {\n    this.state       = CHANNEL_STATES.closed\n    this.topic       = topic\n    this.params      = closure(params || {})\n    this.socket      = socket\n    this.bindings    = []\n    this.bindingRef  = 0\n    this.timeout     = this.socket.timeout\n    this.joinedOnce  = false\n    this.joinPush    = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout)\n    this.pushBuffer  = []\n\n    this.rejoinTimer = new Timer(() => {\n      if(this.socket.isConnected()){ this.rejoin() }\n    }, this.socket.rejoinAfterMs)\n    this.socket.onError(() => this.rejoinTimer.reset())\n    this.socket.onOpen(() => {\n      this.rejoinTimer.reset()\n      if(this.isErrored()){ this.rejoin() }\n    })\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach( pushEvent => pushEvent.send() )\n      this.pushBuffer = []\n    })\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored\n      if(this.socket.isConnected()){ this.rejoinTimer.scheduleTimeout() }\n    })\n    this.onClose(() => {\n      this.rejoinTimer.reset()\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket.remove(this)\n    })\n    this.onError(reason => {\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `error ${this.topic}`, reason)\n      if(this.isJoining()){ this.joinPush.reset() }\n      this.state = CHANNEL_STATES.errored\n      if(this.socket.isConnected()){ this.rejoinTimer.scheduleTimeout() }\n    })\n    this.joinPush.receive(\"timeout\", () => {\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout)\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout)\n      leavePush.send()\n      this.state = CHANNEL_STATES.errored\n      this.joinPush.reset()\n      if(this.socket.isConnected()){ this.rejoinTimer.scheduleTimeout() }\n    })\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload)\n    })\n  }\n\n  /**\n   * Join the channel\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n  join(timeout = this.timeout){\n    if(this.joinedOnce){\n      throw new Error(`tried to join multiple times. 'join' can only be called a single time per channel instance`)\n    } else {\n      this.timeout = timeout\n      this.joinedOnce = true\n      this.rejoin()\n      return this.joinPush\n    }\n  }\n\n  /**\n   * Hook into channel close\n   * @param {Function} callback\n   */\n  onClose(callback){\n    this.on(CHANNEL_EVENTS.close, callback)\n  }\n\n  /**\n   * Hook into channel errors\n   * @param {Function} callback\n   */\n  onError(callback){\n    return this.on(CHANNEL_EVENTS.error, reason => callback(reason))\n  }\n\n  /**\n   * Subscribes on channel events\n   *\n   * Subscription returns a ref counter, which can be used later to\n   * unsubscribe the exact event listener\n   *\n   * @example\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * const ref2 = channel.on(\"event\", do_other_stuff)\n   * channel.off(\"event\", ref1)\n   * // Since unsubscription, do_stuff won't fire,\n   * // while do_other_stuff will keep firing on the \"event\"\n   *\n   * @param {string} event\n   * @param {Function} callback\n   * @returns {integer} ref\n   */\n  on(event, callback){\n    let ref = this.bindingRef++\n    this.bindings.push({event, ref, callback})\n    return ref\n  }\n\n  /**\n   * @param {string} event\n   * @param {integer} ref\n   */\n  off(event, ref){\n    this.bindings = this.bindings.filter((bind) => {\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref))\n    })\n  }\n\n  /**\n   * @private\n   */\n  canPush(){ return this.socket.isConnected() && this.isJoined() }\n\n  /**\n   * @param {string} event\n   * @param {Object} payload\n   * @param {number} [timeout]\n   * @returns {Push}\n   */\n  push(event, payload, timeout = this.timeout){\n    if(!this.joinedOnce){\n      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`)\n    }\n    let pushEvent = new Push(this, event, function(){ return payload }, timeout)\n    if(this.canPush()){\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  /** Leaves the channel\n   *\n   * Unsubscribes from server events, and\n   * instructs channel to terminate on server\n   *\n   * Triggers onClose() hooks\n   *\n   * To receive leave acknowledgements, use the a `receive`\n   * hook to bind to the server ack, ie:\n   *\n   * @example\n   * channel.leave().receive(\"ok\", () => alert(\"left!\") )\n   *\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n  leave(timeout = this.timeout){\n    this.rejoinTimer.reset()\n    this.state = CHANNEL_STATES.leaving\n    let onClose = () => {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", `leave ${this.topic}`)\n      this.trigger(CHANNEL_EVENTS.close, \"leave\")\n    }\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout)\n    leavePush.receive(\"ok\", () => onClose() )\n             .receive(\"timeout\", () => onClose() )\n    leavePush.send()\n    if(!this.canPush()){ leavePush.trigger(\"ok\", {}) }\n\n    return leavePush\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling\n   * before dispatching to the channel callbacks.\n   *\n   * Must return the payload, modified or unmodified\n   * @param {string} event\n   * @param {Object} payload\n   * @param {integer} ref\n   * @returns {Object}\n   */\n  onMessage(event, payload, ref){ return payload }\n\n  /**\n   * @private\n   */\n  isLifecycleEvent(event) { return CHANNEL_LIFECYCLE_EVENTS.indexOf(event) >= 0 }\n\n  /**\n   * @private\n   */\n  isMember(topic, event, payload, joinRef){\n    if(this.topic !== topic){ return false }\n\n    if(joinRef && joinRef !== this.joinRef() && this.isLifecycleEvent(event)){\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", \"dropping outdated message\", {topic, event, payload, joinRef})\n      return false\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * @private\n   */\n  joinRef(){ return this.joinPush.ref }\n\n  /**\n   * @private\n   */\n  sendJoin(timeout){\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  /**\n   * @private\n   */\n  rejoin(timeout = this.timeout){ if(this.isLeaving()){ return }\n    this.sendJoin(timeout)\n  }\n\n  /**\n   * @private\n   */\n  trigger(event, payload, ref, joinRef){\n    let handledPayload = this.onMessage(event, payload, ref, joinRef)\n    if(payload && !handledPayload){ throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\") }\n\n    for (let i = 0; i < this.bindings.length; i++) {\n      const bind = this.bindings[i]\n      if(bind.event !== event){ continue }\n      bind.callback(handledPayload, ref, joinRef || this.joinRef())\n    }\n  }\n\n  /**\n   * @private\n   */\n  replyEventName(ref){ return `chan_reply_${ref}` }\n\n  /**\n   * @private\n   */\n  isClosed() { return this.state === CHANNEL_STATES.closed }\n\n  /**\n   * @private\n   */\n  isErrored(){ return this.state === CHANNEL_STATES.errored }\n\n  /**\n   * @private\n   */\n  isJoined() { return this.state === CHANNEL_STATES.joined }\n\n  /**\n   * @private\n   */\n  isJoining(){ return this.state === CHANNEL_STATES.joining }\n\n  /**\n   * @private\n   */\n  isLeaving(){ return this.state === CHANNEL_STATES.leaving }\n}\n\n/* The default serializer for encoding and decoding messages */\nexport let Serializer = {\n  encode(msg, callback){\n    let payload = [\n      msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload\n    ]\n    return callback(JSON.stringify(payload))\n  },\n\n  decode(rawPayload, callback){\n    let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload)\n\n    return callback({join_ref, ref, topic, event, payload})\n  }\n}\n\n\n/** Initializes the Socket\n *\n *\n * For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n *\n * @param {string} endPoint - The string WebSocket endpoint, ie, `\"ws://example.com/socket\"`,\n *                                               `\"wss://example.com\"`\n *                                               `\"/socket\"` (inherited host & protocol)\n * @param {Object} [opts] - Optional configuration\n * @param {string} [opts.transport] - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n *\n * Defaults to WebSocket with automatic LongPoll fallback.\n * @param {Function} [opts.encode] - The function to encode outgoing messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.stringify(payload))\n * ```\n *\n * @param {Function} [opts.decode] - The function to decode incoming messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.parse(payload))\n * ```\n *\n * @param {number} [opts.timeout] - The default timeout in milliseconds to trigger push timeouts.\n *\n * Defaults `DEFAULT_TIMEOUT`\n * @param {number} [opts.heartbeatIntervalMs] - The millisec interval to send a heartbeat message\n * @param {number} [opts.reconnectAfterMs] - The optional function that returns the millsec\n * socket reconnect interval.\n *\n * Defaults to stepped backoff of:\n *\n * ```javascript\n * function(tries){\n *   return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000\n * }\n * ````\n *\n * @param {number} [opts.rejoinAfterMs] - The optional function that returns the millsec\n * rejoin interval for individual channels.\n *\n * ```javascript\n * function(tries){\n *   return [1000, 2000, 5000][tries - 1] || 10000\n * }\n * ````\n *\n * @param {Function} [opts.logger] - The optional function for specialized logging, ie:\n *\n * ```javascript\n * function(kind, msg, data) {\n *   console.log(`${kind}: ${msg}`, data)\n * }\n * ```\n *\n * @param {number} [opts.longpollerTimeout] - The maximum timeout of a long poll AJAX request.\n *\n * Defaults to 20s (double the server long poll timer).\n *\n * @param {{Object|function)} [opts.params] - The optional params to pass when connecting\n * @param {string} [opts.binaryType] - The binary type to use for binary WebSocket frames.\n *\n * Defaults to \"arraybuffer\"\n *\n*/\nexport class Socket {\n  constructor(endPoint, opts = {}){\n    this.stateChangeCallbacks = {open: [], close: [], error: [], message: []}\n    this.channels             = []\n    this.sendBuffer           = []\n    this.ref                  = 0\n    this.timeout              = opts.timeout || DEFAULT_TIMEOUT\n    this.transport            = opts.transport || global.WebSocket || LongPoll\n    this.defaultEncoder       = Serializer.encode\n    this.defaultDecoder       = Serializer.decode\n    this.closeWasClean        = false\n    this.unloaded             = false\n    this.binaryType           = opts.binaryType || \"arraybuffer\"\n    if(this.transport !== LongPoll){\n      this.encode = opts.encode || this.defaultEncoder\n      this.decode = opts.decode || this.defaultDecoder\n    } else {\n      this.encode = this.defaultEncoder\n      this.decode = this.defaultDecoder\n    }\n    if(globalWindow){\n      globalWindow.addEventListener(\"beforeunload\", e => {\n        this.unloaded = true\n        this.abnormalClose(\"unloaded\")\n      })\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000\n    this.rejoinAfterMs = (tries) => {\n      if(opts.rejoinAfterMs){\n        return opts.rejoinAfterMs(tries)\n      } else {\n        return [1000, 2000, 5000][tries - 1] || 10000\n      }\n    }\n    this.reconnectAfterMs = (tries) => {\n      if(this.unloaded){ return 100 }\n      if(opts.reconnectAfterMs){\n        return opts.reconnectAfterMs(tries)\n      } else {\n        return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000\n      }\n    }\n    this.logger               = opts.logger || null\n    this.longpollerTimeout    = opts.longpollerTimeout || 20000\n    this.params               = closure(opts.params || {})\n    this.endPoint             = `${endPoint}/${TRANSPORTS.websocket}`\n    this.heartbeatTimer       = null\n    this.pendingHeartbeatRef  = null\n    this.reconnectTimer       = new Timer(() => {\n      this.teardown(() => this.connect())\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Returns the socket protocol\n   *\n   * @returns {string}\n   */\n  protocol(){ return location.protocol.match(/^https/) ? \"wss\" : \"ws\" }\n\n  /**\n   * The fully qualifed socket url\n   *\n   * @returns {string}\n   */\n  endPointURL(){\n    let uri = Ajax.appendParams(\n      Ajax.appendParams(this.endPoint, this.params()), {vsn: VSN})\n    if(uri.charAt(0) !== \"/\"){ return uri }\n    if(uri.charAt(1) === \"/\"){ return `${this.protocol()}:${uri}` }\n\n    return `${this.protocol()}://${location.host}${uri}`\n  }\n\n  /**\n   * @param {Function} callback\n   * @param {integer} code\n   * @param {string} reason\n   */\n  disconnect(callback, code, reason){\n    this.closeWasClean = true\n    this.reconnectTimer.reset()\n    this.teardown(callback, code, reason)\n  }\n\n  /**\n   *\n   * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`\n   *\n   * Passing params to connect is deprecated; pass them in the Socket constructor instead:\n   * `new Socket(\"/socket\", {params: {user_id: userToken}})`.\n   */\n  connect(params){\n    if(params){\n      console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\")\n      this.params = closure(params)\n    }\n    if(this.conn){ return }\n\n    this.conn = new this.transport(this.endPointURL())\n    this.conn.binaryType = this.binaryType\n    this.conn.timeout    = this.longpollerTimeout\n    this.conn.onopen     = () => this.onConnOpen()\n    this.conn.onerror    = error => this.onConnError(error)\n    this.conn.onmessage  = event => this.onConnMessage(event)\n    this.conn.onclose    = event => this.onConnClose(event)\n  }\n\n  /**\n   * Logs the message. Override `this.logger` for specialized logging. noops by default\n   * @param {string} kind\n   * @param {string} msg\n   * @param {Object} data\n   */\n  log(kind, msg, data){ this.logger(kind, msg, data) }\n\n  /**\n   * Returns true if a logger has been set on this socket.\n   */\n  hasLogger(){ return this.logger !== null }\n\n  /**\n   * Registers callbacks for connection open events\n   *\n   * @example socket.onOpen(function(){ console.info(\"the socket was opened\") })\n   *\n   * @param {Function} callback\n   */\n  onOpen(callback){ this.stateChangeCallbacks.open.push(callback) }\n\n  /**\n   * Registers callbacks for connection close events\n   * @param {Function} callback\n   */\n  onClose(callback){ this.stateChangeCallbacks.close.push(callback) }\n\n  /**\n   * Registers callbacks for connection error events\n   *\n   * @example socket.onError(function(error){ alert(\"An error occurred\") })\n   *\n   * @param {Function} callback\n   */\n  onError(callback){ this.stateChangeCallbacks.error.push(callback) }\n\n  /**\n   * Registers callbacks for connection message events\n   * @param {Function} callback\n   */\n  onMessage(callback){ this.stateChangeCallbacks.message.push(callback) }\n\n  /**\n   * @private\n   */\n  onConnOpen(){\n    if (this.hasLogger()) this.log(\"transport\", `connected to ${this.endPointURL()}`)\n    this.unloaded = false\n    this.closeWasClean = false\n    this.flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.resetHeartbeat()\n    this.stateChangeCallbacks.open.forEach( callback => callback() )\n  }\n\n  /**\n   * @private\n   */\n\n  resetHeartbeat(){ if(this.conn.skipHeartbeat){ return }\n    this.pendingHeartbeatRef = null\n    clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs)\n  }\n\n  teardown(callback, code, reason){\n    if(this.conn){\n      this.conn.onclose = function(){} // noop\n      if(code){ this.conn.close(code, reason || \"\") } else { this.conn.close() }\n      this.conn = null\n    }\n    callback && callback()\n  }\n\n  onConnClose(event){\n    if (this.hasLogger()) this.log(\"transport\", \"close\", event)\n    this.triggerChanError()\n    clearInterval(this.heartbeatTimer)\n    if(!this.closeWasClean){\n      this.reconnectTimer.scheduleTimeout()\n    }\n    this.stateChangeCallbacks.close.forEach( callback => callback(event) )\n  }\n\n  /**\n   * @private\n   */\n  onConnError(error){\n    if (this.hasLogger()) this.log(\"transport\", error)\n    this.triggerChanError()\n    this.stateChangeCallbacks.error.forEach( callback => callback(error) )\n  }\n\n  /**\n   * @private\n   */\n  triggerChanError(){\n    this.channels.forEach( channel => {\n      if(!(channel.isErrored() || channel.isLeaving() || channel.isClosed())){\n        channel.trigger(CHANNEL_EVENTS.error)\n      }\n    })\n  }\n\n  /**\n   * @returns {string}\n   */\n  connectionState(){\n    switch(this.conn && this.conn.readyState){\n      case SOCKET_STATES.connecting: return \"connecting\"\n      case SOCKET_STATES.open:       return \"open\"\n      case SOCKET_STATES.closing:    return \"closing\"\n      default:                       return \"closed\"\n    }\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  isConnected(){ return this.connectionState() === \"open\" }\n\n  /**\n   * @param {Channel}\n   */\n  remove(channel){\n    this.channels = this.channels.filter(c => c.joinRef() !== channel.joinRef())\n  }\n\n  /**\n   * Initiates a new channel for the given topic\n   *\n   * @param {string} topic\n   * @param {Object} chanParams - Parameters for the channel\n   * @returns {Channel}\n   */\n  channel(topic, chanParams = {}){\n    let chan = new Channel(topic, chanParams, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * @param {Object} data\n   */\n  push(data){\n    if (this.hasLogger()) {\n      let {topic, event, payload, ref, join_ref} = data\n      this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload)\n    }\n\n    if(this.isConnected()){\n      this.encode(data, result => this.conn.send(result))\n    } else {\n      this.sendBuffer.push(() => this.encode(data, result => this.conn.send(result)))\n    }\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   * @returns {string}\n   */\n  makeRef(){\n    let newRef = this.ref + 1\n    if(newRef === this.ref){ this.ref = 0 } else { this.ref = newRef }\n\n    return this.ref.toString()\n  }\n\n  sendHeartbeat(){ if(!this.isConnected()){ return }\n    if(this.pendingHeartbeatRef){\n      this.pendingHeartbeatRef = null\n      if (this.hasLogger()) this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\")\n      this.abnormalClose(\"heartbeat timeout\")\n      return\n    }\n    this.pendingHeartbeatRef = this.makeRef()\n    this.push({topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef})\n  }\n\n  abnormalClose(reason){\n    this.closeWasClean = false\n    this.conn.close(WS_CLOSE_NORMAL, reason)\n  }\n\n  flushSendBuffer(){\n    if(this.isConnected() && this.sendBuffer.length > 0){\n      this.sendBuffer.forEach( callback => callback() )\n      this.sendBuffer = []\n    }\n  }\n\n  onConnMessage(rawMessage){\n    this.decode(rawMessage.data, msg => {\n      let {topic, event, payload, ref, join_ref} = msg\n      if(ref && ref === this.pendingHeartbeatRef){ this.pendingHeartbeatRef = null }\n\n      if (this.hasLogger()) this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload)\n\n      for (let i = 0; i < this.channels.length; i++) {\n        const channel = this.channels[i]\n        if(!channel.isMember(topic, event, payload, join_ref)){ continue }\n        channel.trigger(event, payload, ref, join_ref)\n      }\n\n      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n        this.stateChangeCallbacks.message[i](msg)\n      }\n    })\n  }\n}\n\n\nexport class LongPoll {\n\n  constructor(endPoint){\n    this.endPoint        = null\n    this.token           = null\n    this.skipHeartbeat   = true\n    this.onopen          = function(){} // noop\n    this.onerror         = function(){} // noop\n    this.onmessage       = function(){} // noop\n    this.onclose         = function(){} // noop\n    this.pollEndpoint    = this.normalizeEndpoint(endPoint)\n    this.readyState      = SOCKET_STATES.connecting\n\n    this.poll()\n  }\n\n  normalizeEndpoint(endPoint){\n    return(endPoint\n      .replace(\"ws://\", \"http://\")\n      .replace(\"wss://\", \"https://\")\n      .replace(new RegExp(\"(.*)\\/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll))\n  }\n\n  endpointURL(){\n    return Ajax.appendParams(this.pollEndpoint, {token: this.token})\n  }\n\n  closeAndRetry(){\n    this.close()\n    this.readyState = SOCKET_STATES.connecting\n  }\n\n  ontimeout(){\n    this.onerror(\"timeout\")\n    this.closeAndRetry()\n  }\n\n  poll(){\n    if(!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)){ return }\n\n    Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), (resp) => {\n      if(resp){\n        var {status, token, messages} = resp\n        this.token = token\n      } else{\n        var status = 0\n      }\n\n      switch(status){\n        case 200:\n          messages.forEach(msg => this.onmessage({data: msg}))\n          this.poll()\n          break\n        case 204:\n          this.poll()\n          break\n        case 410:\n          this.readyState = SOCKET_STATES.open\n          this.onopen()\n          this.poll()\n          break\n        case 0:\n        case 500:\n          this.onerror()\n          this.closeAndRetry()\n          break\n        default: throw new Error(`unhandled poll status ${status}`)\n      }\n    })\n  }\n\n  send(body){\n    Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), (resp) => {\n      if(!resp || resp.status !== 200){\n        this.onerror(resp && resp.status)\n        this.closeAndRetry()\n      }\n    })\n  }\n\n  close(code, reason){\n    this.readyState = SOCKET_STATES.closed\n    this.onclose()\n  }\n}\n\nexport class Ajax {\n\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback){\n    if(global.XDomainRequest){\n      let req = new XDomainRequest() // IE8, IE9\n      this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback)\n    } else {\n      let req = global.XMLHttpRequest ?\n                  new global.XMLHttpRequest() : // IE7+, Firefox, Chrome, Opera, Safari\n                  new ActiveXObject(\"Microsoft.XMLHTTP\") // IE6, IE5\n      this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback)\n    }\n  }\n\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback){\n    req.timeout = timeout\n    req.open(method, endPoint)\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText)\n      callback && callback(response)\n    }\n    if(ontimeout){ req.ontimeout = ontimeout }\n\n    // Work around bug in IE9 that requires an attached onprogress handler\n    req.onprogress = () => {}\n\n    req.send(body)\n  }\n\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback){\n    req.open(method, endPoint, true)\n    req.timeout = timeout\n    req.setRequestHeader(\"Content-Type\", accept)\n    req.onerror = () => { callback && callback(null) }\n    req.onreadystatechange = () => {\n      if(req.readyState === this.states.complete && callback){\n        let response = this.parseJSON(req.responseText)\n        callback(response)\n      }\n    }\n    if(ontimeout){ req.ontimeout = ontimeout }\n\n    req.send(body)\n  }\n\n  static parseJSON(resp){\n    if(!resp || resp === \"\"){ return null }\n\n    try {\n      return JSON.parse(resp)\n    } catch(e) {\n      console && console.log(\"failed to parse JSON response\", resp)\n      return null\n    }\n  }\n\n  static serialize(obj, parentKey){\n    let queryStr = []\n    for(var key in obj){ if(!obj.hasOwnProperty(key)){ continue }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key\n      let paramVal = obj[key]\n      if(typeof paramVal === \"object\"){\n        queryStr.push(this.serialize(paramVal, paramKey))\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal))\n      }\n    }\n    return queryStr.join(\"&\")\n  }\n\n  static appendParams(url, params){\n    if(Object.keys(params).length === 0){ return url }\n\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\"\n    return `${url}${prefix}${this.serialize(params)}`\n  }\n}\n\nAjax.states = {complete: 4}\n\n/**\n * Initializes the Presence\n * @param {Channel} channel - The Channel\n * @param {Object} opts - The options,\n *        for example `{events: {state: \"state\", diff: \"diff\"}}`\n */\nexport class Presence {\n\n  constructor(channel, opts = {}){\n    let events = opts.events || {state: \"presence_state\", diff: \"presence_diff\"}\n    this.state = {}\n    this.pendingDiffs = []\n    this.channel = channel\n    this.joinRef = null\n    this.caller = {\n      onJoin: function(){},\n      onLeave: function(){},\n      onSync: function(){}\n    }\n\n    this.channel.on(events.state, newState => {\n      let {onJoin, onLeave, onSync} = this.caller\n\n      this.joinRef = this.channel.joinRef()\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave)\n\n      this.pendingDiffs.forEach(diff => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave)\n      })\n      this.pendingDiffs = []\n      onSync()\n    })\n\n    this.channel.on(events.diff, diff => {\n      let {onJoin, onLeave, onSync} = this.caller\n\n      if(this.inPendingSyncState()){\n        this.pendingDiffs.push(diff)\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave)\n        onSync()\n      }\n    })\n  }\n\n  onJoin(callback){ this.caller.onJoin = callback }\n\n  onLeave(callback){ this.caller.onLeave = callback }\n\n  onSync(callback){ this.caller.onSync = callback }\n\n  list(by){ return Presence.list(this.state, by) }\n\n  inPendingSyncState(){\n    return !this.joinRef || (this.joinRef !== this.channel.joinRef())\n  }\n\n  // lower-level public static API\n\n  /**\n   * Used to sync the list of presences on the server\n   * with the client's state. An optional `onJoin` and `onLeave` callback can\n   * be provided to react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   *\n   * @returns {Presence}\n   */\n  static syncState(currentState, newState, onJoin, onLeave){\n    let state = this.clone(currentState)\n    let joins = {}\n    let leaves = {}\n\n    this.map(state, (key, presence) => {\n      if(!newState[key]){\n        leaves[key] = presence\n      }\n    })\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key]\n      if(currentPresence){\n        let newRefs = newPresence.metas.map(m => m.phx_ref)\n        let curRefs = currentPresence.metas.map(m => m.phx_ref)\n        let joinedMetas = newPresence.metas.filter(m => curRefs.indexOf(m.phx_ref) < 0)\n        let leftMetas = currentPresence.metas.filter(m => newRefs.indexOf(m.phx_ref) < 0)\n        if(joinedMetas.length > 0){\n          joins[key] = newPresence\n          joins[key].metas = joinedMetas\n        }\n        if(leftMetas.length > 0){\n          leaves[key] = this.clone(currentPresence)\n          leaves[key].metas = leftMetas\n        }\n      } else {\n        joins[key] = newPresence\n      }\n    })\n    return this.syncDiff(state, {joins: joins, leaves: leaves}, onJoin, onLeave)\n  }\n\n  /**\n   *\n   * Used to sync a diff of presence join and leave\n   * events from the server, as they happen. Like `syncState`, `syncDiff`\n   * accepts optional `onJoin` and `onLeave` callbacks to react to a user\n   * joining or leaving from a device.\n   *\n   * @returns {Presence}\n   */\n  static syncDiff(currentState, {joins, leaves}, onJoin, onLeave){\n    let state = this.clone(currentState)\n    if(!onJoin){ onJoin = function(){} }\n    if(!onLeave){ onLeave = function(){} }\n\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key]\n      state[key] = newPresence\n      if(currentPresence){\n        let joinedRefs = state[key].metas.map(m => m.phx_ref)\n        let curMetas = currentPresence.metas.filter(m => joinedRefs.indexOf(m.phx_ref) < 0)\n        state[key].metas.unshift(...curMetas)\n      }\n      onJoin(key, currentPresence, newPresence)\n    })\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key]\n      if(!currentPresence){ return }\n      let refsToRemove = leftPresence.metas.map(m => m.phx_ref)\n      currentPresence.metas = currentPresence.metas.filter(p => {\n        return refsToRemove.indexOf(p.phx_ref) < 0\n      })\n      onLeave(key, currentPresence, leftPresence)\n      if(currentPresence.metas.length === 0){\n        delete state[key]\n      }\n    })\n    return state\n  }\n\n  /**\n   * Returns the array of presences, with selected metadata.\n   *\n   * @param {Object} presences\n   * @param {Function} chooser\n   *\n   * @returns {Presence}\n   */\n  static list(presences, chooser){\n    if(!chooser){ chooser = function(key, pres){ return pres } }\n\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence)\n    })\n  }\n\n  // private\n\n  static map(obj, func){\n    return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]))\n  }\n\n  static clone(obj){ return JSON.parse(JSON.stringify(obj)) }\n}\n\n\n/**\n *\n * Creates a timer that accepts a `timerCalc` function to perform\n * calculated timeout retries, such as exponential backoff.\n *\n * @example\n * let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *   return [1000, 5000, 10000][tries - 1] || 10000\n * })\n * reconnectTimer.scheduleTimeout() // fires after 1000\n * reconnectTimer.scheduleTimeout() // fires after 5000\n * reconnectTimer.reset()\n * reconnectTimer.scheduleTimeout() // fires after 1000\n *\n * @param {Function} callback\n * @param {Function} timerCalc\n */\nclass Timer {\n  constructor(callback, timerCalc){\n    this.callback  = callback\n    this.timerCalc = timerCalc\n    this.timer     = null\n    this.tries     = 0\n  }\n\n  reset(){\n    this.tries = 0\n    clearTimeout(this.timer)\n  }\n\n  /**\n   * Cancels any previous scheduleTimeout and schedules callback\n   */\n  scheduleTimeout(){\n    clearTimeout(this.timer)\n\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1))\n  }\n}\n"]},"metadata":{},"sourceType":"module"}