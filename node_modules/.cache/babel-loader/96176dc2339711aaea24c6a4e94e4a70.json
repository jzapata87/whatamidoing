{"ast":null,"code":"import _slicedToArray from \"/Users/javierzapata/Developer/whatamidoing/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * Phoenix Channels JavaScript client\n *\n * ## Socket Connection\n *\n * A single connection is established to the server and\n * channels are multiplexed over the connection.\n * Connect to the server using the `Socket` class:\n *\n * ```javascript\n * let socket = new Socket(\"/socket\", {params: {userToken: \"123\"}})\n * socket.connect()\n * ```\n *\n * The `Socket` constructor takes the mount point of the socket,\n * the authentication params, as well as options that can be found in\n * the Socket docs, such as configuring the `LongPoll` transport, and\n * heartbeat.\n *\n * ## Channels\n *\n * Channels are isolated, concurrent processes on the server that\n * subscribe to topics and broker events between the client and server.\n * To join a channel, you must provide the topic, and channel params for\n * authorization. Here's an example chat room example where `\"new_msg\"`\n * events are listened for, messages are pushed to the server, and\n * the channel is joined with ok/error/timeout matches:\n *\n * ```javascript\n * let channel = socket.channel(\"room:123\", {token: roomToken})\n * channel.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\n * $input.onEnter( e => {\n *   channel.push(\"new_msg\", {body: e.target.val}, 10000)\n *     .receive(\"ok\", (msg) => console.log(\"created message\", msg) )\n *     .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\n *     .receive(\"timeout\", () => console.log(\"Networking issue...\") )\n * })\n *\n * channel.join()\n *   .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\n *   .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\n *   .receive(\"timeout\", () => console.log(\"Networking issue. Still waiting...\"))\n *```\n *\n * ## Joining\n *\n * Creating a channel with `socket.channel(topic, params)`, binds the params to\n * `channel.params`, which are sent up on `channel.join()`.\n * Subsequent rejoins will send up the modified params for\n * updating authorization params, or passing up last_message_id information.\n * Successful joins receive an \"ok\" status, while unsuccessful joins\n * receive \"error\".\n *\n * ## Duplicate Join Subscriptions\n *\n * While the client may join any number of topics on any number of channels,\n * the client may only hold a single subscription for each unique topic at any\n * given time. When attempting to create a duplicate subscription,\n * the server will close the existing channel, log a warning, and\n * spawn a new channel for the topic. The client will have their\n * `channel.onClose` callbacks fired for the existing channel, and the new\n * channel join will have its receive hooks processed as normal.\n *\n * ## Pushing Messages\n *\n * From the previous example, we can see that pushing messages to the server\n * can be done with `channel.push(eventName, payload)` and we can optionally\n * receive responses from the push. Additionally, we can use\n * `receive(\"timeout\", callback)` to abort waiting for our other `receive` hooks\n *  and take action after some period of waiting. The default timeout is 10000ms.\n *\n *\n * ## Socket Hooks\n *\n * Lifecycle events of the multiplexed connection can be hooked into via\n * `socket.onError()` and `socket.onClose()` events, ie:\n *\n * ```javascript\n * socket.onError( () => console.log(\"there was an error with the connection!\") )\n * socket.onClose( () => console.log(\"the connection dropped\") )\n * ```\n *\n *\n * ## Channel Hooks\n *\n * For each joined channel, you can bind to `onError` and `onClose` events\n * to monitor the channel lifecycle, ie:\n *\n * ```javascript\n * channel.onError( () => console.log(\"there was an error!\") )\n * channel.onClose( () => console.log(\"the channel has gone away gracefully\") )\n * ```\n *\n * ### onError hooks\n *\n * `onError` hooks are invoked if the socket connection drops, or the channel\n * crashes on the server. In either case, a channel rejoin is attempted\n * automatically in an exponential backoff manner.\n *\n * ### onClose hooks\n *\n * `onClose` hooks are invoked only in two cases. 1) the channel explicitly\n * closed on the server, or 2). The client explicitly closed, by calling\n * `channel.leave()`\n *\n *\n * ## Presence\n *\n * The `Presence` object provides features for syncing presence information\n * from the server with the client and handling presences joining and leaving.\n *\n * ### Syncing state from the server\n *\n * To sync presence state from the server, first instantiate an object and\n * pass your channel in to track lifecycle events:\n *\n * ```javascript\n * let channel = socket.channel(\"some:topic\")\n * let presence = new Presence(channel)\n * ```\n *\n * Next, use the `presence.onSync` callback to react to state changes\n * from the server. For example, to render the list of users every time\n * the list changes, you could write:\n *\n * ```javascript\n * presence.onSync(() => {\n *   myRenderUsersFunction(presence.list())\n * })\n * ```\n *\n * ### Listing Presences\n *\n * `presence.list` is used to return a list of presence information\n * based on the local state of metadata. By default, all presence\n * metadata is returned, but a `listBy` function can be supplied to\n * allow the client to select which metadata to use for a given presence.\n * For example, you may have a user online from different devices with\n * a metadata status of \"online\", but they have set themselves to \"away\"\n * on another device. In this case, the app may choose to use the \"away\"\n * status for what appears on the UI. The example below defines a `listBy`\n * function which prioritizes the first metadata which was registered for\n * each user. This could be the first tab they opened, or the first device\n * they came online from:\n *\n * ```javascript\n * let listBy = (id, {metas: [first, ...rest]}) => {\n *   first.count = rest.length + 1 // count of this user's presences\n *   first.id = id\n *   return first\n * }\n * let onlineUsers = presence.list(listBy)\n * ```\n *\n * ### Handling individual presence join and leave events\n *\n * The `presence.onJoin` and `presence.onLeave` callbacks can be used to\n * react to individual presences joining and leaving the app. For example:\n *\n * ```javascript\n * let presence = new Presence(channel)\n *\n * // detect if user has joined for the 1st time or from another tab/device\n * presence.onJoin((id, current, newPres) => {\n *   if(!current){\n *     console.log(\"user has entered for the first time\", newPres)\n *   } else {\n *     console.log(\"user additional presence\", newPres)\n *   }\n * })\n *\n * // detect if user has left from all tabs/devices, or is still present\n * presence.onLeave((id, current, leftPres) => {\n *   if(current.metas.length === 0){\n *     console.log(\"user has left from all devices\", leftPres)\n *   } else {\n *     console.log(\"user left from a device\", leftPres)\n *   }\n * })\n * // receive presence data from server\n * presence.onSync(() => {\n *   displayUsers(presence.list())\n * })\n * ```\n * @module phoenix\n */\nconst VSN = \"2.0.0\";\nconst SOCKET_STATES = {\n  connecting: 0,\n  open: 1,\n  closing: 2,\n  closed: 3\n};\nconst DEFAULT_TIMEOUT = 10000;\nconst WS_CLOSE_NORMAL = 1000;\nconst CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\"\n};\nconst CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nconst CHANNEL_LIFECYCLE_EVENTS = [CHANNEL_EVENTS.close, CHANNEL_EVENTS.error, CHANNEL_EVENTS.join, CHANNEL_EVENTS.reply, CHANNEL_EVENTS.leave];\nconst TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\" // wraps value in closure or returns closure\n\n};\n\nlet closure = value => {\n  if (typeof value === \"function\") {\n    return value;\n  } else {\n    let closure = function () {\n      return value;\n    };\n\n    return closure;\n  }\n};\n/**\n * Initializes the Push\n * @param {Channel} channel - The Channel\n * @param {string} event - The event, for example `\"phx_join\"`\n * @param {Object} payload - The payload, for example `{user_id: 123}`\n * @param {number} timeout - The push timeout in milliseconds\n */\n\n\nclass Push {\n  constructor(channel, event, payload, timeout) {\n    this.channel = channel;\n    this.event = event;\n\n    this.payload = payload || function () {\n      return {};\n    };\n\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n  /**\n   *\n   * @param {number} timeout\n   */\n\n\n  resend(timeout) {\n    this.timeout = timeout;\n    this.reset();\n    this.send();\n  }\n  /**\n   *\n   */\n\n\n  send() {\n    if (this.hasReceived(\"timeout\")) {\n      return;\n    }\n\n    this.startTimeout();\n    this.sent = true;\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    });\n  }\n  /**\n   *\n   * @param {*} status\n   * @param {*} callback\n   */\n\n\n  receive(status, callback) {\n    if (this.hasReceived(status)) {\n      callback(this.receivedResp.response);\n    }\n\n    this.recHooks.push({\n      status,\n      callback\n    });\n    return this;\n  }\n  /**\n   * @private\n   */\n\n\n  reset() {\n    this.cancelRefEvent();\n    this.ref = null;\n    this.refEvent = null;\n    this.receivedResp = null;\n    this.sent = false;\n  }\n  /**\n   * @private\n   */\n\n\n  matchReceive({\n    status,\n    response,\n    ref\n  }) {\n    this.recHooks.filter(h => h.status === status).forEach(h => h.callback(response));\n  }\n  /**\n   * @private\n   */\n\n\n  cancelRefEvent() {\n    if (!this.refEvent) {\n      return;\n    }\n\n    this.channel.off(this.refEvent);\n  }\n  /**\n   * @private\n   */\n\n\n  cancelTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = null;\n  }\n  /**\n   * @private\n   */\n\n\n  startTimeout() {\n    if (this.timeoutTimer) {\n      this.cancelTimeout();\n    }\n\n    this.ref = this.channel.socket.makeRef();\n    this.refEvent = this.channel.replyEventName(this.ref);\n    this.channel.on(this.refEvent, payload => {\n      this.cancelRefEvent();\n      this.cancelTimeout();\n      this.receivedResp = payload;\n      this.matchReceive(payload);\n    });\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {});\n    }, this.timeout);\n  }\n  /**\n   * @private\n   */\n\n\n  hasReceived(status) {\n    return this.receivedResp && this.receivedResp.status === status;\n  }\n  /**\n   * @private\n   */\n\n\n  trigger(status, response) {\n    this.channel.trigger(this.refEvent, {\n      status,\n      response\n    });\n  }\n\n}\n/**\n *\n * @param {string} topic\n * @param {(Object|function)} params\n * @param {Socket} socket\n */\n\n\nexport class Channel {\n  constructor(topic, params, socket) {\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = closure(params || {});\n    this.socket = socket;\n    this.bindings = [];\n    this.bindingRef = 0;\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.rejoinTimer = new Timer(() => {\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }, this.socket.rejoinAfterMs);\n    this.socket.onError(() => this.rejoinTimer.reset());\n    this.socket.onOpen(() => {\n      this.rejoinTimer.reset();\n\n      if (this.isErrored()) {\n        this.rejoin();\n      }\n    });\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored;\n\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.onClose(() => {\n      this.rejoinTimer.reset();\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", \"close \".concat(this.topic, \" \").concat(this.joinRef()));\n      this.state = CHANNEL_STATES.closed;\n      this.socket.remove(this);\n    });\n    this.onError(reason => {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", \"error \".concat(this.topic), reason);\n\n      if (this.isJoining()) {\n        this.joinPush.reset();\n      }\n\n      this.state = CHANNEL_STATES.errored;\n\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.joinPush.receive(\"timeout\", () => {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", \"timeout \".concat(this.topic, \" (\").concat(this.joinRef(), \")\"), this.joinPush.timeout);\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n      leavePush.send();\n      this.state = CHANNEL_STATES.errored;\n      this.joinPush.reset();\n\n      if (this.socket.isConnected()) {\n        this.rejoinTimer.scheduleTimeout();\n      }\n    });\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload);\n    });\n  }\n  /**\n   * Join the channel\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n\n\n  join(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n    } else {\n      this.timeout = timeout;\n      this.joinedOnce = true;\n      this.rejoin();\n      return this.joinPush;\n    }\n  }\n  /**\n   * Hook into channel close\n   * @param {Function} callback\n   */\n\n\n  onClose(callback) {\n    this.on(CHANNEL_EVENTS.close, callback);\n  }\n  /**\n   * Hook into channel errors\n   * @param {Function} callback\n   */\n\n\n  onError(callback) {\n    return this.on(CHANNEL_EVENTS.error, reason => callback(reason));\n  }\n  /**\n   * Subscribes on channel events\n   *\n   * Subscription returns a ref counter, which can be used later to\n   * unsubscribe the exact event listener\n   *\n   * @example\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * const ref2 = channel.on(\"event\", do_other_stuff)\n   * channel.off(\"event\", ref1)\n   * // Since unsubscription, do_stuff won't fire,\n   * // while do_other_stuff will keep firing on the \"event\"\n   *\n   * @param {string} event\n   * @param {Function} callback\n   * @returns {integer} ref\n   */\n\n\n  on(event, callback) {\n    let ref = this.bindingRef++;\n    this.bindings.push({\n      event,\n      ref,\n      callback\n    });\n    return ref;\n  }\n  /**\n   * @param {string} event\n   * @param {integer} ref\n   */\n\n\n  off(event, ref) {\n    this.bindings = this.bindings.filter(bind => {\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  canPush() {\n    return this.socket.isConnected() && this.isJoined();\n  }\n  /**\n   * @param {string} event\n   * @param {Object} payload\n   * @param {number} [timeout]\n   * @returns {Push}\n   */\n\n\n  push(event, payload, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw new Error(\"tried to push '\".concat(event, \"' to '\").concat(this.topic, \"' before joining. Use channel.join() before pushing events\"));\n    }\n\n    let pushEvent = new Push(this, event, function () {\n      return payload;\n    }, timeout);\n\n    if (this.canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n\n    return pushEvent;\n  }\n  /** Leaves the channel\n   *\n   * Unsubscribes from server events, and\n   * instructs channel to terminate on server\n   *\n   * Triggers onClose() hooks\n   *\n   * To receive leave acknowledgements, use the a `receive`\n   * hook to bind to the server ack, ie:\n   *\n   * @example\n   * channel.leave().receive(\"ok\", () => alert(\"left!\") )\n   *\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n\n\n  leave(timeout = this.timeout) {\n    this.rejoinTimer.reset();\n    this.state = CHANNEL_STATES.leaving;\n\n    let onClose = () => {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", \"leave \".concat(this.topic));\n      this.trigger(CHANNEL_EVENTS.close, \"leave\");\n    };\n\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n    leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\n    leavePush.send();\n\n    if (!this.canPush()) {\n      leavePush.trigger(\"ok\", {});\n    }\n\n    return leavePush;\n  }\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling\n   * before dispatching to the channel callbacks.\n   *\n   * Must return the payload, modified or unmodified\n   * @param {string} event\n   * @param {Object} payload\n   * @param {integer} ref\n   * @returns {Object}\n   */\n\n\n  onMessage(event, payload, ref) {\n    return payload;\n  }\n  /**\n   * @private\n   */\n\n\n  isLifecycleEvent(event) {\n    return CHANNEL_LIFECYCLE_EVENTS.indexOf(event) >= 0;\n  }\n  /**\n   * @private\n   */\n\n\n  isMember(topic, event, payload, joinRef) {\n    if (this.topic !== topic) {\n      return false;\n    }\n\n    if (joinRef && joinRef !== this.joinRef() && this.isLifecycleEvent(event)) {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", \"dropping outdated message\", {\n        topic,\n        event,\n        payload,\n        joinRef\n      });\n      return false;\n    } else {\n      return true;\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  joinRef() {\n    return this.joinPush.ref;\n  }\n  /**\n   * @private\n   */\n\n\n  sendJoin(timeout) {\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  /**\n   * @private\n   */\n\n\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return;\n    }\n\n    this.sendJoin(timeout);\n  }\n  /**\n   * @private\n   */\n\n\n  trigger(event, payload, ref, joinRef) {\n    let handledPayload = this.onMessage(event, payload, ref, joinRef);\n\n    if (payload && !handledPayload) {\n      throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n    }\n\n    for (let i = 0; i < this.bindings.length; i++) {\n      const bind = this.bindings[i];\n\n      if (bind.event !== event) {\n        continue;\n      }\n\n      bind.callback(handledPayload, ref, joinRef || this.joinRef());\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  replyEventName(ref) {\n    return \"chan_reply_\".concat(ref);\n  }\n  /**\n   * @private\n   */\n\n\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  /**\n   * @private\n   */\n\n\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored;\n  }\n  /**\n   * @private\n   */\n\n\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  /**\n   * @private\n   */\n\n\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  /**\n   * @private\n   */\n\n\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n\n}\n/* The default serializer for encoding and decoding messages */\n\nexport let Serializer = {\n  encode(msg, callback) {\n    let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n    return callback(JSON.stringify(payload));\n  },\n\n  decode(rawPayload, callback) {\n    let _JSON$parse = JSON.parse(rawPayload),\n        _JSON$parse2 = _slicedToArray(_JSON$parse, 5),\n        join_ref = _JSON$parse2[0],\n        ref = _JSON$parse2[1],\n        topic = _JSON$parse2[2],\n        event = _JSON$parse2[3],\n        payload = _JSON$parse2[4];\n\n    return callback({\n      join_ref,\n      ref,\n      topic,\n      event,\n      payload\n    });\n  }\n\n};\n/** Initializes the Socket\n *\n *\n * For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n *\n * @param {string} endPoint - The string WebSocket endpoint, ie, `\"ws://example.com/socket\"`,\n *                                               `\"wss://example.com\"`\n *                                               `\"/socket\"` (inherited host & protocol)\n * @param {Object} [opts] - Optional configuration\n * @param {string} [opts.transport] - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n *\n * Defaults to WebSocket with automatic LongPoll fallback.\n * @param {Function} [opts.encode] - The function to encode outgoing messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.stringify(payload))\n * ```\n *\n * @param {Function} [opts.decode] - The function to decode incoming messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.parse(payload))\n * ```\n *\n * @param {number} [opts.timeout] - The default timeout in milliseconds to trigger push timeouts.\n *\n * Defaults `DEFAULT_TIMEOUT`\n * @param {number} [opts.heartbeatIntervalMs] - The millisec interval to send a heartbeat message\n * @param {number} [opts.reconnectAfterMs] - The optional function that returns the millsec\n * socket reconnect interval.\n *\n * Defaults to stepped backoff of:\n *\n * ```javascript\n * function(tries){\n *   return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000\n * }\n * ````\n *\n * @param {number} [opts.rejoinAfterMs] - The optional function that returns the millsec\n * rejoin interval for individual channels.\n *\n * ```javascript\n * function(tries){\n *   return [1000, 2000, 5000][tries - 1] || 10000\n * }\n * ````\n *\n * @param {Function} [opts.logger] - The optional function for specialized logging, ie:\n *\n * ```javascript\n * function(kind, msg, data) {\n *   console.log(`${kind}: ${msg}`, data)\n * }\n * ```\n *\n * @param {number} [opts.longpollerTimeout] - The maximum timeout of a long poll AJAX request.\n *\n * Defaults to 20s (double the server long poll timer).\n *\n * @param {{Object|function)} [opts.params] - The optional params to pass when connecting\n * @param {string} [opts.binaryType] - The binary type to use for binary WebSocket frames.\n *\n * Defaults to \"arraybuffer\"\n *\n*/\n\nexport class LongPoll {\n  constructor(endPoint) {\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n\n    this.onopen = function () {}; // noop\n\n\n    this.onerror = function () {}; // noop\n\n\n    this.onmessage = function () {}; // noop\n\n\n    this.onclose = function () {}; // noop\n\n\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n    this.poll();\n  }\n\n  normalizeEndpoint(endPoint) {\n    return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)\\/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n  }\n\n  endpointURL() {\n    return Ajax.appendParams(this.pollEndpoint, {\n      token: this.token\n    });\n  }\n\n  closeAndRetry() {\n    this.close();\n    this.readyState = SOCKET_STATES.connecting;\n  }\n\n  ontimeout() {\n    this.onerror(\"timeout\");\n    this.closeAndRetry();\n  }\n\n  poll() {\n    if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n      return;\n    }\n\n    Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), resp => {\n      if (resp) {\n        var status = resp.status,\n            token = resp.token,\n            messages = resp.messages;\n        this.token = token;\n      } else {\n        var status = 0;\n      }\n\n      switch (status) {\n        case 200:\n          messages.forEach(msg => this.onmessage({\n            data: msg\n          }));\n          this.poll();\n          break;\n\n        case 204:\n          this.poll();\n          break;\n\n        case 410:\n          this.readyState = SOCKET_STATES.open;\n          this.onopen();\n          this.poll();\n          break;\n\n        case 0:\n        case 500:\n          this.onerror();\n          this.closeAndRetry();\n          break;\n\n        default:\n          throw new Error(\"unhandled poll status \".concat(status));\n      }\n    });\n  }\n\n  send(body) {\n    Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), resp => {\n      if (!resp || resp.status !== 200) {\n        this.onerror(resp && resp.status);\n        this.closeAndRetry();\n      }\n    });\n  }\n\n  close(code, reason) {\n    this.readyState = SOCKET_STATES.closed;\n    this.onclose();\n  }\n\n}\nexport class Ajax {\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n    if (global.XDomainRequest) {\n      let req = new XDomainRequest(); // IE8, IE9\n\n      this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n    } else {\n      let req = global.XMLHttpRequest ? new global.XMLHttpRequest() : // IE7+, Firefox, Chrome, Opera, Safari\n      new ActiveXObject(\"Microsoft.XMLHTTP\"); // IE6, IE5\n\n      this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n    }\n  }\n\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n    req.timeout = timeout;\n    req.open(method, endPoint);\n\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText);\n      callback && callback(response);\n    };\n\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    } // Work around bug in IE9 that requires an attached onprogress handler\n\n\n    req.onprogress = () => {};\n\n    req.send(body);\n  }\n\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n    req.open(method, endPoint, true);\n    req.timeout = timeout;\n    req.setRequestHeader(\"Content-Type\", accept);\n\n    req.onerror = () => {\n      callback && callback(null);\n    };\n\n    req.onreadystatechange = () => {\n      if (req.readyState === this.states.complete && callback) {\n        let response = this.parseJSON(req.responseText);\n        callback(response);\n      }\n    };\n\n    if (ontimeout) {\n      req.ontimeout = ontimeout;\n    }\n\n    req.send(body);\n  }\n\n  static parseJSON(resp) {\n    if (!resp || resp === \"\") {\n      return null;\n    }\n\n    try {\n      return JSON.parse(resp);\n    } catch (e) {\n      console && console.log(\"failed to parse JSON response\", resp);\n      return null;\n    }\n  }\n\n  static serialize(obj, parentKey) {\n    let queryStr = [];\n\n    for (var key in obj) {\n      if (!obj.hasOwnProperty(key)) {\n        continue;\n      }\n\n      let paramKey = parentKey ? \"\".concat(parentKey, \"[\").concat(key, \"]\") : key;\n      let paramVal = obj[key];\n\n      if (typeof paramVal === \"object\") {\n        queryStr.push(this.serialize(paramVal, paramKey));\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n      }\n    }\n\n    return queryStr.join(\"&\");\n  }\n\n  static appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\";\n    return \"\".concat(url).concat(prefix).concat(this.serialize(params));\n  }\n\n}\nAjax.states = {\n  complete: 4\n  /**\n   * Initializes the Presence\n   * @param {Channel} channel - The Channel\n   * @param {Object} opts - The options,\n   *        for example `{events: {state: \"state\", diff: \"diff\"}}`\n   */\n\n};\nexport class Presence {\n  constructor(channel, opts = {}) {\n    let events = opts.events || {\n      state: \"presence_state\",\n      diff: \"presence_diff\"\n    };\n    this.state = {};\n    this.pendingDiffs = [];\n    this.channel = channel;\n    this.joinRef = null;\n    this.caller = {\n      onJoin: function () {},\n      onLeave: function () {},\n      onSync: function () {}\n    };\n    this.channel.on(events.state, newState => {\n      let _this$caller = this.caller,\n          onJoin = _this$caller.onJoin,\n          onLeave = _this$caller.onLeave,\n          onSync = _this$caller.onSync;\n      this.joinRef = this.channel.joinRef();\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n      this.pendingDiffs.forEach(diff => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n      });\n      this.pendingDiffs = [];\n      onSync();\n    });\n    this.channel.on(events.diff, diff => {\n      let _this$caller2 = this.caller,\n          onJoin = _this$caller2.onJoin,\n          onLeave = _this$caller2.onLeave,\n          onSync = _this$caller2.onSync;\n\n      if (this.inPendingSyncState()) {\n        this.pendingDiffs.push(diff);\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        onSync();\n      }\n    });\n  }\n\n  onJoin(callback) {\n    this.caller.onJoin = callback;\n  }\n\n  onLeave(callback) {\n    this.caller.onLeave = callback;\n  }\n\n  onSync(callback) {\n    this.caller.onSync = callback;\n  }\n\n  list(by) {\n    return Presence.list(this.state, by);\n  }\n\n  inPendingSyncState() {\n    return !this.joinRef || this.joinRef !== this.channel.joinRef();\n  } // lower-level public static API\n\n  /**\n   * Used to sync the list of presences on the server\n   * with the client's state. An optional `onJoin` and `onLeave` callback can\n   * be provided to react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   *\n   * @returns {Presence}\n   */\n\n\n  static syncState(currentState, newState, onJoin, onLeave) {\n    let state = this.clone(currentState);\n    let joins = {};\n    let leaves = {};\n    this.map(state, (key, presence) => {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key];\n\n      if (currentPresence) {\n        let newRefs = newPresence.metas.map(m => m.phx_ref);\n        let curRefs = currentPresence.metas.map(m => m.phx_ref);\n        let joinedMetas = newPresence.metas.filter(m => curRefs.indexOf(m.phx_ref) < 0);\n        let leftMetas = currentPresence.metas.filter(m => newRefs.indexOf(m.phx_ref) < 0);\n\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence;\n          joins[key].metas = joinedMetas;\n        }\n\n        if (leftMetas.length > 0) {\n          leaves[key] = this.clone(currentPresence);\n          leaves[key].metas = leftMetas;\n        }\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, {\n      joins: joins,\n      leaves: leaves\n    }, onJoin, onLeave);\n  }\n  /**\n   *\n   * Used to sync a diff of presence join and leave\n   * events from the server, as they happen. Like `syncState`, `syncDiff`\n   * accepts optional `onJoin` and `onLeave` callbacks to react to a user\n   * joining or leaving from a device.\n   *\n   * @returns {Presence}\n   */\n\n\n  static syncDiff(currentState, {\n    joins,\n    leaves\n  }, onJoin, onLeave) {\n    let state = this.clone(currentState);\n\n    if (!onJoin) {\n      onJoin = function () {};\n    }\n\n    if (!onLeave) {\n      onLeave = function () {};\n    }\n\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key];\n      state[key] = newPresence;\n\n      if (currentPresence) {\n        let joinedRefs = state[key].metas.map(m => m.phx_ref);\n        let curMetas = currentPresence.metas.filter(m => joinedRefs.indexOf(m.phx_ref) < 0);\n        state[key].metas.unshift(...curMetas);\n      }\n\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key];\n\n      if (!currentPresence) {\n        return;\n      }\n\n      let refsToRemove = leftPresence.metas.map(m => m.phx_ref);\n      currentPresence.metas = currentPresence.metas.filter(p => {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  }\n  /**\n   * Returns the array of presences, with selected metadata.\n   *\n   * @param {Object} presences\n   * @param {Function} chooser\n   *\n   * @returns {Presence}\n   */\n\n\n  static list(presences, chooser) {\n    if (!chooser) {\n      chooser = function (key, pres) {\n        return pres;\n      };\n    }\n\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence);\n    });\n  } // private\n\n\n  static map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]));\n  }\n\n  static clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n}\n/**\n *\n * Creates a timer that accepts a `timerCalc` function to perform\n * calculated timeout retries, such as exponential backoff.\n *\n * @example\n * let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *   return [1000, 5000, 10000][tries - 1] || 10000\n * })\n * reconnectTimer.scheduleTimeout() // fires after 1000\n * reconnectTimer.scheduleTimeout() // fires after 5000\n * reconnectTimer.reset()\n * reconnectTimer.scheduleTimeout() // fires after 1000\n *\n * @param {Function} callback\n * @param {Function} timerCalc\n */\n\nclass Timer {\n  constructor(callback, timerCalc) {\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n\n  reset() {\n    this.tries = 0;\n    clearTimeout(this.timer);\n  }\n  /**\n   * Cancels any previous scheduleTimeout and schedules callback\n   */\n\n\n  scheduleTimeout() {\n    clearTimeout(this.timer);\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1;\n      this.callback();\n    }, this.timerCalc(this.tries + 1));\n  }\n\n}","map":{"version":3,"sources":["/Users/javierzapata/Developer/whatamidoing/src/phoenix.js"],"names":["VSN","SOCKET_STATES","connecting","open","closing","closed","DEFAULT_TIMEOUT","WS_CLOSE_NORMAL","CHANNEL_STATES","errored","joined","joining","leaving","CHANNEL_EVENTS","close","error","join","reply","leave","CHANNEL_LIFECYCLE_EVENTS","TRANSPORTS","longpoll","websocket","closure","value","Push","constructor","channel","event","payload","timeout","receivedResp","timeoutTimer","recHooks","sent","resend","reset","send","hasReceived","startTimeout","socket","push","topic","ref","join_ref","joinRef","receive","status","callback","response","cancelRefEvent","refEvent","matchReceive","filter","h","forEach","off","cancelTimeout","clearTimeout","makeRef","replyEventName","on","setTimeout","trigger","Channel","params","state","bindings","bindingRef","joinedOnce","joinPush","pushBuffer","rejoinTimer","Timer","isConnected","rejoin","rejoinAfterMs","onError","onOpen","isErrored","pushEvent","scheduleTimeout","onClose","hasLogger","log","remove","reason","isJoining","leavePush","Error","bind","canPush","isJoined","onMessage","isLifecycleEvent","indexOf","isMember","sendJoin","isLeaving","handledPayload","i","length","isClosed","Serializer","encode","msg","JSON","stringify","decode","rawPayload","parse","LongPoll","endPoint","token","skipHeartbeat","onopen","onerror","onmessage","onclose","pollEndpoint","normalizeEndpoint","readyState","poll","replace","RegExp","endpointURL","Ajax","appendParams","closeAndRetry","ontimeout","request","resp","messages","data","body","code","method","accept","global","XDomainRequest","req","xdomainRequest","XMLHttpRequest","ActiveXObject","xhrRequest","onload","parseJSON","responseText","onprogress","setRequestHeader","onreadystatechange","states","complete","e","console","serialize","obj","parentKey","queryStr","key","hasOwnProperty","paramKey","paramVal","encodeURIComponent","url","Object","keys","prefix","match","Presence","opts","events","diff","pendingDiffs","caller","onJoin","onLeave","onSync","newState","syncState","syncDiff","inPendingSyncState","list","by","currentState","clone","joins","leaves","map","presence","newPresence","currentPresence","newRefs","metas","m","phx_ref","curRefs","joinedMetas","leftMetas","joinedRefs","curMetas","unshift","leftPresence","refsToRemove","p","presences","chooser","pres","func","getOwnPropertyNames","timerCalc","timer","tries"],"mappings":"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","sourcesContent":["/**\n * Phoenix Channels JavaScript client\n *\n * ## Socket Connection\n *\n * A single connection is established to the server and\n * channels are multiplexed over the connection.\n * Connect to the server using the `Socket` class:\n *\n * ```javascript\n * let socket = new Socket(\"/socket\", {params: {userToken: \"123\"}})\n * socket.connect()\n * ```\n *\n * The `Socket` constructor takes the mount point of the socket,\n * the authentication params, as well as options that can be found in\n * the Socket docs, such as configuring the `LongPoll` transport, and\n * heartbeat.\n *\n * ## Channels\n *\n * Channels are isolated, concurrent processes on the server that\n * subscribe to topics and broker events between the client and server.\n * To join a channel, you must provide the topic, and channel params for\n * authorization. Here's an example chat room example where `\"new_msg\"`\n * events are listened for, messages are pushed to the server, and\n * the channel is joined with ok/error/timeout matches:\n *\n * ```javascript\n * let channel = socket.channel(\"room:123\", {token: roomToken})\n * channel.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\n * $input.onEnter( e => {\n *   channel.push(\"new_msg\", {body: e.target.val}, 10000)\n *     .receive(\"ok\", (msg) => console.log(\"created message\", msg) )\n *     .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\n *     .receive(\"timeout\", () => console.log(\"Networking issue...\") )\n * })\n *\n * channel.join()\n *   .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\n *   .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\n *   .receive(\"timeout\", () => console.log(\"Networking issue. Still waiting...\"))\n *```\n *\n * ## Joining\n *\n * Creating a channel with `socket.channel(topic, params)`, binds the params to\n * `channel.params`, which are sent up on `channel.join()`.\n * Subsequent rejoins will send up the modified params for\n * updating authorization params, or passing up last_message_id information.\n * Successful joins receive an \"ok\" status, while unsuccessful joins\n * receive \"error\".\n *\n * ## Duplicate Join Subscriptions\n *\n * While the client may join any number of topics on any number of channels,\n * the client may only hold a single subscription for each unique topic at any\n * given time. When attempting to create a duplicate subscription,\n * the server will close the existing channel, log a warning, and\n * spawn a new channel for the topic. The client will have their\n * `channel.onClose` callbacks fired for the existing channel, and the new\n * channel join will have its receive hooks processed as normal.\n *\n * ## Pushing Messages\n *\n * From the previous example, we can see that pushing messages to the server\n * can be done with `channel.push(eventName, payload)` and we can optionally\n * receive responses from the push. Additionally, we can use\n * `receive(\"timeout\", callback)` to abort waiting for our other `receive` hooks\n *  and take action after some period of waiting. The default timeout is 10000ms.\n *\n *\n * ## Socket Hooks\n *\n * Lifecycle events of the multiplexed connection can be hooked into via\n * `socket.onError()` and `socket.onClose()` events, ie:\n *\n * ```javascript\n * socket.onError( () => console.log(\"there was an error with the connection!\") )\n * socket.onClose( () => console.log(\"the connection dropped\") )\n * ```\n *\n *\n * ## Channel Hooks\n *\n * For each joined channel, you can bind to `onError` and `onClose` events\n * to monitor the channel lifecycle, ie:\n *\n * ```javascript\n * channel.onError( () => console.log(\"there was an error!\") )\n * channel.onClose( () => console.log(\"the channel has gone away gracefully\") )\n * ```\n *\n * ### onError hooks\n *\n * `onError` hooks are invoked if the socket connection drops, or the channel\n * crashes on the server. In either case, a channel rejoin is attempted\n * automatically in an exponential backoff manner.\n *\n * ### onClose hooks\n *\n * `onClose` hooks are invoked only in two cases. 1) the channel explicitly\n * closed on the server, or 2). The client explicitly closed, by calling\n * `channel.leave()`\n *\n *\n * ## Presence\n *\n * The `Presence` object provides features for syncing presence information\n * from the server with the client and handling presences joining and leaving.\n *\n * ### Syncing state from the server\n *\n * To sync presence state from the server, first instantiate an object and\n * pass your channel in to track lifecycle events:\n *\n * ```javascript\n * let channel = socket.channel(\"some:topic\")\n * let presence = new Presence(channel)\n * ```\n *\n * Next, use the `presence.onSync` callback to react to state changes\n * from the server. For example, to render the list of users every time\n * the list changes, you could write:\n *\n * ```javascript\n * presence.onSync(() => {\n *   myRenderUsersFunction(presence.list())\n * })\n * ```\n *\n * ### Listing Presences\n *\n * `presence.list` is used to return a list of presence information\n * based on the local state of metadata. By default, all presence\n * metadata is returned, but a `listBy` function can be supplied to\n * allow the client to select which metadata to use for a given presence.\n * For example, you may have a user online from different devices with\n * a metadata status of \"online\", but they have set themselves to \"away\"\n * on another device. In this case, the app may choose to use the \"away\"\n * status for what appears on the UI. The example below defines a `listBy`\n * function which prioritizes the first metadata which was registered for\n * each user. This could be the first tab they opened, or the first device\n * they came online from:\n *\n * ```javascript\n * let listBy = (id, {metas: [first, ...rest]}) => {\n *   first.count = rest.length + 1 // count of this user's presences\n *   first.id = id\n *   return first\n * }\n * let onlineUsers = presence.list(listBy)\n * ```\n *\n * ### Handling individual presence join and leave events\n *\n * The `presence.onJoin` and `presence.onLeave` callbacks can be used to\n * react to individual presences joining and leaving the app. For example:\n *\n * ```javascript\n * let presence = new Presence(channel)\n *\n * // detect if user has joined for the 1st time or from another tab/device\n * presence.onJoin((id, current, newPres) => {\n *   if(!current){\n *     console.log(\"user has entered for the first time\", newPres)\n *   } else {\n *     console.log(\"user additional presence\", newPres)\n *   }\n * })\n *\n * // detect if user has left from all tabs/devices, or is still present\n * presence.onLeave((id, current, leftPres) => {\n *   if(current.metas.length === 0){\n *     console.log(\"user has left from all devices\", leftPres)\n *   } else {\n *     console.log(\"user left from a device\", leftPres)\n *   }\n * })\n * // receive presence data from server\n * presence.onSync(() => {\n *   displayUsers(presence.list())\n * })\n * ```\n * @module phoenix\n */\n\n\nconst VSN = \"2.0.0\"\nconst SOCKET_STATES = {connecting: 0, open: 1, closing: 2, closed: 3}\nconst DEFAULT_TIMEOUT = 10000\nconst WS_CLOSE_NORMAL = 1000\nconst CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\",\n}\nconst CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n}\nconst CHANNEL_LIFECYCLE_EVENTS = [\n  CHANNEL_EVENTS.close,\n  CHANNEL_EVENTS.error,\n  CHANNEL_EVENTS.join,\n  CHANNEL_EVENTS.reply,\n  CHANNEL_EVENTS.leave\n]\nconst TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n}\n\n// wraps value in closure or returns closure\nlet closure = (value) => {\n  if(typeof value === \"function\"){\n    return value\n  } else {\n    let closure = function(){ return value }\n    return closure\n  }\n}\n\n/**\n * Initializes the Push\n * @param {Channel} channel - The Channel\n * @param {string} event - The event, for example `\"phx_join\"`\n * @param {Object} payload - The payload, for example `{user_id: 123}`\n * @param {number} timeout - The push timeout in milliseconds\n */\nclass Push {\n  constructor(channel, event, payload, timeout){\n    this.channel      = channel\n    this.event        = event\n    this.payload      = payload || function(){ return {} }\n    this.receivedResp = null\n    this.timeout      = timeout\n    this.timeoutTimer = null\n    this.recHooks     = []\n    this.sent         = false\n  }\n\n  /**\n   *\n   * @param {number} timeout\n   */\n  resend(timeout){\n    this.timeout = timeout\n    this.reset()\n    this.send()\n  }\n\n  /**\n   *\n   */\n  send(){ if(this.hasReceived(\"timeout\")){ return }\n    this.startTimeout()\n    this.sent = true\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload(),\n      ref: this.ref,\n      join_ref: this.channel.joinRef()\n    })\n  }\n\n  /**\n   *\n   * @param {*} status\n   * @param {*} callback\n   */\n  receive(status, callback){\n    if(this.hasReceived(status)){\n      callback(this.receivedResp.response)\n    }\n\n    this.recHooks.push({status, callback})\n    return this\n  }\n\n  /**\n   * @private\n   */\n  reset(){\n    this.cancelRefEvent()\n    this.ref          = null\n    this.refEvent     = null\n    this.receivedResp = null\n    this.sent         = false\n  }\n\n  /**\n   * @private\n   */\n  matchReceive({status, response, ref}){\n    this.recHooks.filter( h => h.status === status )\n                 .forEach( h => h.callback(response) )\n  }\n\n  /**\n   * @private\n   */\n  cancelRefEvent(){ if(!this.refEvent){ return }\n    this.channel.off(this.refEvent)\n  }\n\n  /**\n   * @private\n   */\n  cancelTimeout(){\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = null\n  }\n\n  /**\n   * @private\n   */\n  startTimeout(){ if(this.timeoutTimer){ this.cancelTimeout() }\n    this.ref      = this.channel.socket.makeRef()\n    this.refEvent = this.channel.replyEventName(this.ref)\n\n    this.channel.on(this.refEvent, payload => {\n      this.cancelRefEvent()\n      this.cancelTimeout()\n      this.receivedResp = payload\n      this.matchReceive(payload)\n    })\n\n    this.timeoutTimer = setTimeout(() => {\n      this.trigger(\"timeout\", {})\n    }, this.timeout)\n  }\n\n  /**\n   * @private\n   */\n  hasReceived(status){\n    return this.receivedResp && this.receivedResp.status === status\n  }\n\n  /**\n   * @private\n   */\n  trigger(status, response){\n    this.channel.trigger(this.refEvent, {status, response})\n  }\n}\n\n/**\n *\n * @param {string} topic\n * @param {(Object|function)} params\n * @param {Socket} socket\n */\nexport class Channel {\n  constructor(topic, params, socket) {\n    this.state       = CHANNEL_STATES.closed\n    this.topic       = topic\n    this.params      = closure(params || {})\n    this.socket      = socket\n    this.bindings    = []\n    this.bindingRef  = 0\n    this.timeout     = this.socket.timeout\n    this.joinedOnce  = false\n    this.joinPush    = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout)\n    this.pushBuffer  = []\n\n    this.rejoinTimer = new Timer(() => {\n      if(this.socket.isConnected()){ this.rejoin() }\n    }, this.socket.rejoinAfterMs)\n    this.socket.onError(() => this.rejoinTimer.reset())\n    this.socket.onOpen(() => {\n      this.rejoinTimer.reset()\n      if(this.isErrored()){ this.rejoin() }\n    })\n    this.joinPush.receive(\"ok\", () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach( pushEvent => pushEvent.send() )\n      this.pushBuffer = []\n    })\n    this.joinPush.receive(\"error\", () => {\n      this.state = CHANNEL_STATES.errored\n      if(this.socket.isConnected()){ this.rejoinTimer.scheduleTimeout() }\n    })\n    this.onClose(() => {\n      this.rejoinTimer.reset()\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket.remove(this)\n    })\n    this.onError(reason => {\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `error ${this.topic}`, reason)\n      if(this.isJoining()){ this.joinPush.reset() }\n      this.state = CHANNEL_STATES.errored\n      if(this.socket.isConnected()){ this.rejoinTimer.scheduleTimeout() }\n    })\n    this.joinPush.receive(\"timeout\", () => {\n      if(this.socket.hasLogger()) this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout)\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout)\n      leavePush.send()\n      this.state = CHANNEL_STATES.errored\n      this.joinPush.reset()\n      if(this.socket.isConnected()){ this.rejoinTimer.scheduleTimeout() }\n    })\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n      this.trigger(this.replyEventName(ref), payload)\n    })\n  }\n\n  /**\n   * Join the channel\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n  join(timeout = this.timeout){\n    if(this.joinedOnce){\n      throw new Error(`tried to join multiple times. 'join' can only be called a single time per channel instance`)\n    } else {\n      this.timeout = timeout\n      this.joinedOnce = true\n      this.rejoin()\n      return this.joinPush\n    }\n  }\n\n  /**\n   * Hook into channel close\n   * @param {Function} callback\n   */\n  onClose(callback){\n    this.on(CHANNEL_EVENTS.close, callback)\n  }\n\n  /**\n   * Hook into channel errors\n   * @param {Function} callback\n   */\n  onError(callback){\n    return this.on(CHANNEL_EVENTS.error, reason => callback(reason))\n  }\n\n  /**\n   * Subscribes on channel events\n   *\n   * Subscription returns a ref counter, which can be used later to\n   * unsubscribe the exact event listener\n   *\n   * @example\n   * const ref1 = channel.on(\"event\", do_stuff)\n   * const ref2 = channel.on(\"event\", do_other_stuff)\n   * channel.off(\"event\", ref1)\n   * // Since unsubscription, do_stuff won't fire,\n   * // while do_other_stuff will keep firing on the \"event\"\n   *\n   * @param {string} event\n   * @param {Function} callback\n   * @returns {integer} ref\n   */\n  on(event, callback){\n    let ref = this.bindingRef++\n    this.bindings.push({event, ref, callback})\n    return ref\n  }\n\n  /**\n   * @param {string} event\n   * @param {integer} ref\n   */\n  off(event, ref){\n    this.bindings = this.bindings.filter((bind) => {\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref))\n    })\n  }\n\n  /**\n   * @private\n   */\n  canPush(){ return this.socket.isConnected() && this.isJoined() }\n\n  /**\n   * @param {string} event\n   * @param {Object} payload\n   * @param {number} [timeout]\n   * @returns {Push}\n   */\n  push(event, payload, timeout = this.timeout){\n    if(!this.joinedOnce){\n      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`)\n    }\n    let pushEvent = new Push(this, event, function(){ return payload }, timeout)\n    if(this.canPush()){\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  /** Leaves the channel\n   *\n   * Unsubscribes from server events, and\n   * instructs channel to terminate on server\n   *\n   * Triggers onClose() hooks\n   *\n   * To receive leave acknowledgements, use the a `receive`\n   * hook to bind to the server ack, ie:\n   *\n   * @example\n   * channel.leave().receive(\"ok\", () => alert(\"left!\") )\n   *\n   * @param {integer} timeout\n   * @returns {Push}\n   */\n  leave(timeout = this.timeout){\n    this.rejoinTimer.reset()\n    this.state = CHANNEL_STATES.leaving\n    let onClose = () => {\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", `leave ${this.topic}`)\n      this.trigger(CHANNEL_EVENTS.close, \"leave\")\n    }\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout)\n    leavePush.receive(\"ok\", () => onClose() )\n             .receive(\"timeout\", () => onClose() )\n    leavePush.send()\n    if(!this.canPush()){ leavePush.trigger(\"ok\", {}) }\n\n    return leavePush\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling\n   * before dispatching to the channel callbacks.\n   *\n   * Must return the payload, modified or unmodified\n   * @param {string} event\n   * @param {Object} payload\n   * @param {integer} ref\n   * @returns {Object}\n   */\n  onMessage(event, payload, ref){ return payload }\n\n  /**\n   * @private\n   */\n  isLifecycleEvent(event) { return CHANNEL_LIFECYCLE_EVENTS.indexOf(event) >= 0 }\n\n  /**\n   * @private\n   */\n  isMember(topic, event, payload, joinRef){\n    if(this.topic !== topic){ return false }\n\n    if(joinRef && joinRef !== this.joinRef() && this.isLifecycleEvent(event)){\n      if (this.socket.hasLogger()) this.socket.log(\"channel\", \"dropping outdated message\", {topic, event, payload, joinRef})\n      return false\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * @private\n   */\n  joinRef(){ return this.joinPush.ref }\n\n  /**\n   * @private\n   */\n  sendJoin(timeout){\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  /**\n   * @private\n   */\n  rejoin(timeout = this.timeout){ if(this.isLeaving()){ return }\n    this.sendJoin(timeout)\n  }\n\n  /**\n   * @private\n   */\n  trigger(event, payload, ref, joinRef){\n    let handledPayload = this.onMessage(event, payload, ref, joinRef)\n    if(payload && !handledPayload){ throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\") }\n\n    for (let i = 0; i < this.bindings.length; i++) {\n      const bind = this.bindings[i]\n      if(bind.event !== event){ continue }\n      bind.callback(handledPayload, ref, joinRef || this.joinRef())\n    }\n  }\n\n  /**\n   * @private\n   */\n  replyEventName(ref){ return `chan_reply_${ref}` }\n\n  /**\n   * @private\n   */\n  isClosed() { return this.state === CHANNEL_STATES.closed }\n\n  /**\n   * @private\n   */\n  isErrored(){ return this.state === CHANNEL_STATES.errored }\n\n  /**\n   * @private\n   */\n  isJoined() { return this.state === CHANNEL_STATES.joined }\n\n  /**\n   * @private\n   */\n  isJoining(){ return this.state === CHANNEL_STATES.joining }\n\n  /**\n   * @private\n   */\n  isLeaving(){ return this.state === CHANNEL_STATES.leaving }\n}\n\n/* The default serializer for encoding and decoding messages */\nexport let Serializer = {\n  encode(msg, callback){\n    let payload = [\n      msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload\n    ]\n    return callback(JSON.stringify(payload))\n  },\n\n  decode(rawPayload, callback){\n    let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload)\n\n    return callback({join_ref, ref, topic, event, payload})\n  }\n}\n\n\n/** Initializes the Socket\n *\n *\n * For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n *\n * @param {string} endPoint - The string WebSocket endpoint, ie, `\"ws://example.com/socket\"`,\n *                                               `\"wss://example.com\"`\n *                                               `\"/socket\"` (inherited host & protocol)\n * @param {Object} [opts] - Optional configuration\n * @param {string} [opts.transport] - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n *\n * Defaults to WebSocket with automatic LongPoll fallback.\n * @param {Function} [opts.encode] - The function to encode outgoing messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.stringify(payload))\n * ```\n *\n * @param {Function} [opts.decode] - The function to decode incoming messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.parse(payload))\n * ```\n *\n * @param {number} [opts.timeout] - The default timeout in milliseconds to trigger push timeouts.\n *\n * Defaults `DEFAULT_TIMEOUT`\n * @param {number} [opts.heartbeatIntervalMs] - The millisec interval to send a heartbeat message\n * @param {number} [opts.reconnectAfterMs] - The optional function that returns the millsec\n * socket reconnect interval.\n *\n * Defaults to stepped backoff of:\n *\n * ```javascript\n * function(tries){\n *   return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000\n * }\n * ````\n *\n * @param {number} [opts.rejoinAfterMs] - The optional function that returns the millsec\n * rejoin interval for individual channels.\n *\n * ```javascript\n * function(tries){\n *   return [1000, 2000, 5000][tries - 1] || 10000\n * }\n * ````\n *\n * @param {Function} [opts.logger] - The optional function for specialized logging, ie:\n *\n * ```javascript\n * function(kind, msg, data) {\n *   console.log(`${kind}: ${msg}`, data)\n * }\n * ```\n *\n * @param {number} [opts.longpollerTimeout] - The maximum timeout of a long poll AJAX request.\n *\n * Defaults to 20s (double the server long poll timer).\n *\n * @param {{Object|function)} [opts.params] - The optional params to pass when connecting\n * @param {string} [opts.binaryType] - The binary type to use for binary WebSocket frames.\n *\n * Defaults to \"arraybuffer\"\n *\n*/\n\n\n\nexport class LongPoll {\n\n  constructor(endPoint){\n    this.endPoint        = null\n    this.token           = null\n    this.skipHeartbeat   = true\n    this.onopen          = function(){} // noop\n    this.onerror         = function(){} // noop\n    this.onmessage       = function(){} // noop\n    this.onclose         = function(){} // noop\n    this.pollEndpoint    = this.normalizeEndpoint(endPoint)\n    this.readyState      = SOCKET_STATES.connecting\n\n    this.poll()\n  }\n\n  normalizeEndpoint(endPoint){\n    return(endPoint\n      .replace(\"ws://\", \"http://\")\n      .replace(\"wss://\", \"https://\")\n      .replace(new RegExp(\"(.*)\\/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll))\n  }\n\n  endpointURL(){\n    return Ajax.appendParams(this.pollEndpoint, {token: this.token})\n  }\n\n  closeAndRetry(){\n    this.close()\n    this.readyState = SOCKET_STATES.connecting\n  }\n\n  ontimeout(){\n    this.onerror(\"timeout\")\n    this.closeAndRetry()\n  }\n\n  poll(){\n    if(!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)){ return }\n\n    Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), (resp) => {\n      if(resp){\n        var {status, token, messages} = resp\n        this.token = token\n      } else{\n        var status = 0\n      }\n\n      switch(status){\n        case 200:\n          messages.forEach(msg => this.onmessage({data: msg}))\n          this.poll()\n          break\n        case 204:\n          this.poll()\n          break\n        case 410:\n          this.readyState = SOCKET_STATES.open\n          this.onopen()\n          this.poll()\n          break\n        case 0:\n        case 500:\n          this.onerror()\n          this.closeAndRetry()\n          break\n        default: throw new Error(`unhandled poll status ${status}`)\n      }\n    })\n  }\n\n  send(body){\n    Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), (resp) => {\n      if(!resp || resp.status !== 200){\n        this.onerror(resp && resp.status)\n        this.closeAndRetry()\n      }\n    })\n  }\n\n  close(code, reason){\n    this.readyState = SOCKET_STATES.closed\n    this.onclose()\n  }\n}\n\nexport class Ajax {\n\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback){\n    if(global.XDomainRequest){\n      let req = new XDomainRequest() // IE8, IE9\n      this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback)\n    } else {\n      let req = global.XMLHttpRequest ?\n                  new global.XMLHttpRequest() : // IE7+, Firefox, Chrome, Opera, Safari\n                  new ActiveXObject(\"Microsoft.XMLHTTP\") // IE6, IE5\n      this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback)\n    }\n  }\n\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback){\n    req.timeout = timeout\n    req.open(method, endPoint)\n    req.onload = () => {\n      let response = this.parseJSON(req.responseText)\n      callback && callback(response)\n    }\n    if(ontimeout){ req.ontimeout = ontimeout }\n\n    // Work around bug in IE9 that requires an attached onprogress handler\n    req.onprogress = () => {}\n\n    req.send(body)\n  }\n\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback){\n    req.open(method, endPoint, true)\n    req.timeout = timeout\n    req.setRequestHeader(\"Content-Type\", accept)\n    req.onerror = () => { callback && callback(null) }\n    req.onreadystatechange = () => {\n      if(req.readyState === this.states.complete && callback){\n        let response = this.parseJSON(req.responseText)\n        callback(response)\n      }\n    }\n    if(ontimeout){ req.ontimeout = ontimeout }\n\n    req.send(body)\n  }\n\n  static parseJSON(resp){\n    if(!resp || resp === \"\"){ return null }\n\n    try {\n      return JSON.parse(resp)\n    } catch(e) {\n      console && console.log(\"failed to parse JSON response\", resp)\n      return null\n    }\n  }\n\n  static serialize(obj, parentKey){\n    let queryStr = []\n    for(var key in obj){ if(!obj.hasOwnProperty(key)){ continue }\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key\n      let paramVal = obj[key]\n      if(typeof paramVal === \"object\"){\n        queryStr.push(this.serialize(paramVal, paramKey))\n      } else {\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal))\n      }\n    }\n    return queryStr.join(\"&\")\n  }\n\n  static appendParams(url, params){\n    if(Object.keys(params).length === 0){ return url }\n\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\"\n    return `${url}${prefix}${this.serialize(params)}`\n  }\n}\n\nAjax.states = {complete: 4}\n\n/**\n * Initializes the Presence\n * @param {Channel} channel - The Channel\n * @param {Object} opts - The options,\n *        for example `{events: {state: \"state\", diff: \"diff\"}}`\n */\nexport class Presence {\n\n  constructor(channel, opts = {}){\n    let events = opts.events || {state: \"presence_state\", diff: \"presence_diff\"}\n    this.state = {}\n    this.pendingDiffs = []\n    this.channel = channel\n    this.joinRef = null\n    this.caller = {\n      onJoin: function(){},\n      onLeave: function(){},\n      onSync: function(){}\n    }\n\n    this.channel.on(events.state, newState => {\n      let {onJoin, onLeave, onSync} = this.caller\n\n      this.joinRef = this.channel.joinRef()\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave)\n\n      this.pendingDiffs.forEach(diff => {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave)\n      })\n      this.pendingDiffs = []\n      onSync()\n    })\n\n    this.channel.on(events.diff, diff => {\n      let {onJoin, onLeave, onSync} = this.caller\n\n      if(this.inPendingSyncState()){\n        this.pendingDiffs.push(diff)\n      } else {\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave)\n        onSync()\n      }\n    })\n  }\n\n  onJoin(callback){ this.caller.onJoin = callback }\n\n  onLeave(callback){ this.caller.onLeave = callback }\n\n  onSync(callback){ this.caller.onSync = callback }\n\n  list(by){ return Presence.list(this.state, by) }\n\n  inPendingSyncState(){\n    return !this.joinRef || (this.joinRef !== this.channel.joinRef())\n  }\n\n  // lower-level public static API\n\n  /**\n   * Used to sync the list of presences on the server\n   * with the client's state. An optional `onJoin` and `onLeave` callback can\n   * be provided to react to changes in the client's local presences across\n   * disconnects and reconnects with the server.\n   *\n   * @returns {Presence}\n   */\n  static syncState(currentState, newState, onJoin, onLeave){\n    let state = this.clone(currentState)\n    let joins = {}\n    let leaves = {}\n\n    this.map(state, (key, presence) => {\n      if(!newState[key]){\n        leaves[key] = presence\n      }\n    })\n    this.map(newState, (key, newPresence) => {\n      let currentPresence = state[key]\n      if(currentPresence){\n        let newRefs = newPresence.metas.map(m => m.phx_ref)\n        let curRefs = currentPresence.metas.map(m => m.phx_ref)\n        let joinedMetas = newPresence.metas.filter(m => curRefs.indexOf(m.phx_ref) < 0)\n        let leftMetas = currentPresence.metas.filter(m => newRefs.indexOf(m.phx_ref) < 0)\n        if(joinedMetas.length > 0){\n          joins[key] = newPresence\n          joins[key].metas = joinedMetas\n        }\n        if(leftMetas.length > 0){\n          leaves[key] = this.clone(currentPresence)\n          leaves[key].metas = leftMetas\n        }\n      } else {\n        joins[key] = newPresence\n      }\n    })\n    return this.syncDiff(state, {joins: joins, leaves: leaves}, onJoin, onLeave)\n  }\n\n  /**\n   *\n   * Used to sync a diff of presence join and leave\n   * events from the server, as they happen. Like `syncState`, `syncDiff`\n   * accepts optional `onJoin` and `onLeave` callbacks to react to a user\n   * joining or leaving from a device.\n   *\n   * @returns {Presence}\n   */\n  static syncDiff(currentState, {joins, leaves}, onJoin, onLeave){\n    let state = this.clone(currentState)\n    if(!onJoin){ onJoin = function(){} }\n    if(!onLeave){ onLeave = function(){} }\n\n    this.map(joins, (key, newPresence) => {\n      let currentPresence = state[key]\n      state[key] = newPresence\n      if(currentPresence){\n        let joinedRefs = state[key].metas.map(m => m.phx_ref)\n        let curMetas = currentPresence.metas.filter(m => joinedRefs.indexOf(m.phx_ref) < 0)\n        state[key].metas.unshift(...curMetas)\n      }\n      onJoin(key, currentPresence, newPresence)\n    })\n    this.map(leaves, (key, leftPresence) => {\n      let currentPresence = state[key]\n      if(!currentPresence){ return }\n      let refsToRemove = leftPresence.metas.map(m => m.phx_ref)\n      currentPresence.metas = currentPresence.metas.filter(p => {\n        return refsToRemove.indexOf(p.phx_ref) < 0\n      })\n      onLeave(key, currentPresence, leftPresence)\n      if(currentPresence.metas.length === 0){\n        delete state[key]\n      }\n    })\n    return state\n  }\n\n  /**\n   * Returns the array of presences, with selected metadata.\n   *\n   * @param {Object} presences\n   * @param {Function} chooser\n   *\n   * @returns {Presence}\n   */\n  static list(presences, chooser){\n    if(!chooser){ chooser = function(key, pres){ return pres } }\n\n    return this.map(presences, (key, presence) => {\n      return chooser(key, presence)\n    })\n  }\n\n  // private\n\n  static map(obj, func){\n    return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]))\n  }\n\n  static clone(obj){ return JSON.parse(JSON.stringify(obj)) }\n}\n\n\n/**\n *\n * Creates a timer that accepts a `timerCalc` function to perform\n * calculated timeout retries, such as exponential backoff.\n *\n * @example\n * let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *   return [1000, 5000, 10000][tries - 1] || 10000\n * })\n * reconnectTimer.scheduleTimeout() // fires after 1000\n * reconnectTimer.scheduleTimeout() // fires after 5000\n * reconnectTimer.reset()\n * reconnectTimer.scheduleTimeout() // fires after 1000\n *\n * @param {Function} callback\n * @param {Function} timerCalc\n */\nclass Timer {\n  constructor(callback, timerCalc){\n    this.callback  = callback\n    this.timerCalc = timerCalc\n    this.timer     = null\n    this.tries     = 0\n  }\n\n  reset(){\n    this.tries = 0\n    clearTimeout(this.timer)\n  }\n\n  /**\n   * Cancels any previous scheduleTimeout and schedules callback\n   */\n  scheduleTimeout(){\n    clearTimeout(this.timer)\n\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1))\n  }\n}\n"]},"metadata":{},"sourceType":"module"}